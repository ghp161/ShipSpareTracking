This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.devcontainer/devcontainer.json
.replit
.repomix/bundles.json
.streamlit/config.toml
app_settings.py
barcode_handler.py
data_manager.py
main.py
navbar.py
pages/admin.py
pages/analytics.py
pages/departments.py
pages/inventory.py
pages/operations.py
pages/reports.py
pyproject.toml
repl_nix_workspace.egg-info/dependency_links.txt
repl_nix_workspace.egg-info/PKG-INFO
repl_nix_workspace.egg-info/requires.txt
repl_nix_workspace.egg-info/SOURCES.txt
repl_nix_workspace.egg-info/top_level.txt
replit.nix
user_management.py
utils.py

================================================================
Files
================================================================

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: pages/departments.py
================
import streamlit as st
import pandas as pd
import sqlite3
from user_management import login_required
import navbar
from app_settings import set_page_configuration

set_page_configuration()

current_page = "Departments"
st.header(current_page)

navbar.nav(current_page)

class DepartmentManager:
    def __init__(self, db_path='inventory.db'):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.create_departments_table()

    def create_departments_table(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS departments (
                id INTEGER PRIMARY KEY,
                code TEXT UNIQUE NOT NULL,
                name TEXT NOT NULL,
                parent_id INTEGER,
                FOREIGN KEY (parent_id) REFERENCES departments (id)
            )
        ''')
        self.conn.commit()

    def update_department(self, dept_id, code, name, parent_id=None):
        cursor = self.conn.cursor()
        try:
            # Prevent circular references
            if parent_id == dept_id:
                return False, "Department cannot be its own parent"
                
            cursor.execute('''
                UPDATE departments 
                SET code=?, name=?, parent_id=?
                WHERE id=?
            ''', (code, name, parent_id, dept_id))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)

    def delete_department(self, dept_id):
        cursor = self.conn.cursor()
        try:
            # Check if department has children
            cursor.execute("SELECT COUNT(*) FROM departments WHERE parent_id=?", (dept_id,))
            child_count = cursor.fetchone()[0]
            if child_count > 0:
                return False, "Cannot delete department with child departments"

            # Check if department is used in spare_parts
            cursor.execute("SELECT COUNT(*) FROM spare_parts WHERE department_id=?", (dept_id,))
            part_count = cursor.fetchone()[0]
            if part_count > 0:
                return False, f"Cannot delete department - {part_count} inventory items reference it"

            cursor.execute("DELETE FROM departments WHERE id=?", (dept_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)

    def add_department(self, code, name, parent_id=None):
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                INSERT INTO departments (code, name, parent_id)
                VALUES (?, ?, ?)
            ''', (code, name, parent_id))
            self.conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False

    def get_all_departments_as_df(self):
        """Returns department data as a pandas DataFrame"""
        query = '''
            SELECT d1.id, d1.code, d1.name, 
                   COALESCE(d2.name, 'Top Level') as parent_name
            FROM departments d1
            LEFT JOIN departments d2 ON d1.parent_id = d2.id
            ORDER BY COALESCE(d1.parent_id, d1.id), d1.id
        '''
        return pd.read_sql_query(query, self.conn)

    def get_parent_options(self):
        """Returns options for parent department dropdown"""
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT id, name FROM departments WHERE parent_id IS NULL
        ''')
        return cursor.fetchall()

@login_required
def render_departments_page():
    if 'dept_manager' not in st.session_state:
        st.session_state.dept_manager = DepartmentManager()

    tab1, tab2 = st.tabs(["Department Grid", "Add Department"])

    with tab1:
        #st.subheader("Department Data Grid")
        
        # Get data as DataFrame
        df = st.session_state.dept_manager.get_all_departments_as_df()
        
        if not df.empty:
            # Display as interactive grid
            st.dataframe(
                df,
                column_config={
                    "id": "ID",
                    "code": "Code",
                    "name": "Department Name",
                    "parent_name": "Parent Department"
                },
                hide_index=True,
                use_container_width=True
            )
            
            # Add edit/delete functionality
            st.subheader("Edit Department")
            dept_id = st.selectbox(
                "Select Department to Edit",
                df['id'],
                format_func=lambda x: f"{df[df['id']==x]['code'].iloc[0]} - {df[df['id']==x]['name'].iloc[0]}"
            )
            
            if dept_id:
                dept_data = df[df['id'] == dept_id].iloc[0]
                with st.form(f"edit_form_{dept_id}"):
                    new_code = st.text_input("Code", value=dept_data['code'])
                    new_name = st.text_input("Name", value=dept_data['name'])
                    
                    parent_options = st.session_state.dept_manager.get_parent_options()
                    current_parent = None if dept_data['parent_name'] == 'Top Level' else \
                        next((p[0] for p in parent_options if p[1] == dept_data['parent_name']), None)
                    
                    parent_id = st.selectbox(
                        "Parent Department",
                        [None] + [p[0] for p in parent_options],
                        format_func=lambda x: "Top Level" if x is None else \
                            next((p[1] for p in parent_options if p[0] == x), "None"),
                        index=0 if current_parent is None else \
                            [p[0] for p in parent_options].index(current_parent) + 1
                    )
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        if st.form_submit_button("Update"):
                            # Implement update logic
                            if st.session_state.dept_manager.update_department(dept_id, new_code, new_name, parent_id):
                                st.rerun()
                                st.success("Department Updated successfully")                                
                            else:
                                st.error("Department code already exists")
                    with col2:
                        if st.form_submit_button("Delete"):
                            # Implement delete logic
                            success, message = st.session_state.dept_manager.delete_department(dept_id)
                            if success:
                                st.rerun()
                                st.success("Department deleted successfully!")                                
                            else:
                                st.error(f"Deletion failed: {message}")
        else:
            st.info("No departments found")

    with tab2:
        #st.subheader("Add New Department")
        with st.form("add_department_form"):
            code = st.text_input("Department Code", max_chars=10)
            name = st.text_input("Department Name")
            
            parent_options = st.session_state.dept_manager.get_parent_options()
            is_parent = st.checkbox("This is a top-level department", value=True)
            
            parent_id = None
            if not is_parent and parent_options:
                parent_id = st.selectbox(
                    "Parent Department",
                    [p[0] for p in parent_options],
                    format_func=lambda x: next((p[1] for p in parent_options if p[0] == x), None),
                    index=0
                )
            
            if st.form_submit_button("Add Department"):
                if code and name:
                    if st.session_state.dept_manager.add_department(code, name, parent_id):
                        st.success("Department added successfully")
                        st.rerun()
                    else:
                        st.error("Department code already exists")
                else:
                    st.error("Please fill in all required fields")

if __name__ == "__main__":
    render_departments_page()

================
File: .devcontainer/devcontainer.json
================
{
  "name": "Python 3",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/python:1-3.11-bullseye",
  "customizations": {
    "codespaces": {
      "openFiles": [
        "README.md",
        "main.py"
      ]
    },
    "vscode": {
      "settings": {},
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance"
      ]
    }
  },
  "updateContentCommand": "[ -f packages.txt ] && sudo apt update && sudo apt upgrade -y && sudo xargs apt install -y <packages.txt; [ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user streamlit; echo 'âœ… Packages installed and Requirements met'",
  "postAttachCommand": {
    "server": "streamlit run main.py --server.enableCORS false --server.enableXsrfProtection false"
  },
  "portsAttributes": {
    "8501": {
      "label": "Application",
      "onAutoForward": "openPreview"
    }
  },
  "forwardPorts": [
    8501
  ]
}

================
File: app_settings.py
================
import streamlit as st

def set_page_configuration():
    # Set page configuration
    st.set_page_config(
        page_title="Ship Inventory Management System",
        page_icon="ðŸš¢",
        layout="wide",
        initial_sidebar_state="expanded"
    )

    # Reducing whitespace on the top of the page
    st.markdown("""
    <style>
    
            .stAppHeader {
                background-color: rgba(255, 255, 255, 0.0);  /* Transparent background */
                visibility: visible;  /* Ensure the header is visible */
            }

           /* Remove blank space at top and bottom */ 
           .block-container {
               padding-top: 0rem;
               padding-bottom: 0rem;
            }
           
           /* Remove blank space at the center canvas */ 
           .st-emotion-cache-z5fcl4 {
               position: relative;
               top: -62px;
               }
           
           /* Make the toolbar transparent and the content below it clickable */ 
           .st-emotion-cache-18ni7ap {
               pointer-events: none;
               background: rgb(255 255 255 / 0%)
               }
           .st-emotion-cache-zq5wmm {
               pointer-events: auto;
               background: rgb(255 255 255);
               border-radius: 5px;
               }
    </style>
    """, unsafe_allow_html=True)

================
File: repl_nix_workspace.egg-info/dependency_links.txt
================


================
File: repl_nix_workspace.egg-info/PKG-INFO
================
Metadata-Version: 2.4
Name: repl-nix-workspace
Version: 0.1.0
Summary: Add your description here
Requires-Python: >=3.11
Requires-Dist: barcode>=1.0.4
Requires-Dist: numpy>=2.2.3
Requires-Dist: pandas>=2.2.3
Requires-Dist: pillow>=11.1.0
Requires-Dist: plotly>=6.0.0
Requires-Dist: python-barcode>=0.15.1
Requires-Dist: streamlit-option-menu>=0.4.0
Requires-Dist: streamlit>=1.43.1
Requires-Dist: trafilatura>=2.0.0

================
File: repl_nix_workspace.egg-info/requires.txt
================
barcode>=1.0.4
numpy>=2.2.3
pandas>=2.2.3
pillow>=11.1.0
plotly>=6.0.0
python-barcode>=0.15.1
streamlit-option-menu>=0.4.0
streamlit>=1.43.1
trafilatura>=2.0.0

================
File: repl_nix_workspace.egg-info/SOURCES.txt
================
pyproject.toml
pages/admin.py
pages/analytics.py
pages/inventory.py
pages/operations.py
pages/reports.py
repl_nix_workspace.egg-info/PKG-INFO
repl_nix_workspace.egg-info/SOURCES.txt
repl_nix_workspace.egg-info/dependency_links.txt
repl_nix_workspace.egg-info/requires.txt
repl_nix_workspace.egg-info/top_level.txt

================
File: repl_nix_workspace.egg-info/top_level.txt
================
pages

================
File: replit.nix
================
{pkgs}: {
  deps = [
    pkgs.glibcLocales
    pkgs.zlib
    pkgs.tk
    pkgs.tcl
    pkgs.openjpeg
    pkgs.libxcrypt
    pkgs.libwebp
    pkgs.libtiff
    pkgs.libjpeg
    pkgs.libimagequant
    pkgs.lcms2
    pkgs.freetype
  ];
}

================
File: .replit
================
modules = ["python-3.11"]

[nix]
channel = "stable-24_05"

[deployment]
deploymentTarget = "autoscale"
run = ["sh", "-c", "streamlit run main.py"]

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Streamlit App"

[[workflows.workflow]]
name = "Streamlit App"
author = "agent"

[workflows.workflow.metadata]
agentRequireRestartOnSave = false

[[workflows.workflow.tasks]]
task = "packager.installForAll"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "streamlit run main.py"
waitForPort = 5000

[[ports]]
localPort = 5000
externalPort = 80

[[ports]]
localPort = 8501
externalPort = 3000

================
File: barcode_handler.py
================
import barcode
from barcode.writer import ImageWriter
import io
import base64
import re
from barcode import *

class BarcodeHandler:
    @staticmethod
    def generate_barcode(value):
        # Generate Code128 barcode
        barcode_class = barcode.get_barcode_class('code128')
        rv = io.BytesIO()
        barcode_class(value, writer=ImageWriter()).write(rv)
        return base64.b64encode(rv.getvalue()).decode()

    @staticmethod
    def generate_unique_barcode(prefix="SP"):
        import random
        import string

        # Generate a random 8-character string
        random_part = ''.join(random.choices(string.digits, k=8))
        return f"{prefix}{random_part}"

    @staticmethod
    def validate_barcode(barcode_input):
        """Validate barcode format and clean input"""
        # Remove any non-alphanumeric characters (like newlines from scanner)
        cleaned_input = re.sub(r'[^a-zA-Z0-9]', '', barcode_input)

        # Check if it matches our format (SP + 8 digits)
        if re.match(r'^SP\d{8}$', cleaned_input):
            return True, cleaned_input
        return False, None

    @staticmethod
    def get_part_by_barcode(data_manager, barcode_input):
        """Look up a part using its barcode"""
        try:
            df = data_manager.get_all_parts()
            part = df[df['barcode'] == barcode_input]
            if not part.empty:
                return True, part.iloc[0]
            return False, None
        except Exception as e:
            print(f"Error looking up barcode: {e}")
            return False, None

================
File: utils.py
================
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from datetime import datetime, timedelta

def create_stock_level_chart(df):
    fig = px.bar(
        df,
        x='name',
        y=['quantity', 'min_order_level'],
        title='Stock Levels vs Minimum Order Levels',
        barmode='group'
    )
    return fig

def create_transaction_trend(df):
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    daily_transactions = df.groupby(['timestamp', 'transaction_type']).size().reset_index(name='count')

    fig = px.line(
        daily_transactions,
        x='timestamp',
        y='count',
        color='transaction_type',
        title='Transaction Trends'
    )
    return fig

def format_transaction_table(df):
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df = df.sort_values('timestamp', ascending=False)
    return df[['timestamp', 'name', 'part_number', 'transaction_type', 'quantity']]

def calculate_moving_average(data, window=7):
    """Calculate moving average for demand forecasting"""
    return data.rolling(window=window).mean()

def calculate_exponential_smoothing(data, alpha=0.3):
    """Calculate exponential smoothing for trend analysis"""
    return data.ewm(alpha=alpha, adjust=False).mean()

def calculate_reorder_point(df, part_id, lead_time_days=7):
    """Calculate reorder point based on average daily demand and lead time"""
    part_transactions = df[df['part_id'] == part_id]
    if part_transactions.empty:
        return 0

    # Calculate daily demand
    daily_demand = part_transactions.groupby('timestamp')['quantity'].sum()
    avg_daily_demand = abs(daily_demand.mean())

    # Add safety stock (20% of lead time demand)
    safety_stock = avg_daily_demand * lead_time_days * 0.2
    reorder_point = (avg_daily_demand * lead_time_days) + safety_stock

    return round(reorder_point)

def calculate_stock_turnover(df, current_stock):
    """Calculate stock turnover rate"""
    if df.empty or current_stock == 0:
        return 0

    total_usage = abs(df[df['transaction_type'] == 'check_out']['quantity'].sum())
    avg_inventory = current_stock / 2  # Simple average inventory calculation

    if avg_inventory == 0:
        return 0

    turnover_rate = total_usage / avg_inventory
    return round(turnover_rate, 2)

def create_demand_forecast_chart(df, part_id, days_to_forecast=30):
    """Create demand forecast visualization"""
    part_transactions = df[df['part_id'] == part_id]
    if part_transactions.empty:
        return None

    # Prepare daily demand data
    daily_demand = part_transactions.groupby('timestamp')['quantity'].sum()

    # Calculate moving average and exponential smoothing
    ma = calculate_moving_average(daily_demand)
    ema = calculate_exponential_smoothing(daily_demand)

    # Create forecast dates
    last_date = daily_demand.index.max()
    forecast_dates = pd.date_range(
        start=last_date, 
        periods=days_to_forecast + 1, 
        freq='D'
    )[1:]

    # Create forecast values using the last 7 days trend
    last_week_trend = ema[-7:].mean()
    forecast_values = [last_week_trend] * days_to_forecast

    # Create visualization
    fig = go.Figure()

    # Historical data
    fig.add_trace(go.Scatter(
        x=daily_demand.index,
        y=daily_demand.values,
        name='Actual Demand',
        mode='lines+markers'
    ))

    # Moving average
    fig.add_trace(go.Scatter(
        x=ma.index,
        y=ma.values,
        name='7-Day Moving Average',
        line=dict(dash='dash')
    ))

    # Exponential moving average
    fig.add_trace(go.Scatter(
        x=ema.index,
        y=ema.values,
        name='Exponential Moving Average',
        line=dict(dash='dot')
    ))

    # Forecast
    fig.add_trace(go.Scatter(
        x=forecast_dates,
        y=forecast_values,
        name='Forecast',
        line=dict(dash='dashdot')
    ))

    fig.update_layout(
        title='Demand Forecast Analysis',
        xaxis_title='Date',
        yaxis_title='Quantity',
        showlegend=True
    )

    return fig

================
File: pages/admin.py
================
import streamlit as st
import pandas as pd
import sqlite3
from user_management import login_required
import navbar
from app_settings import set_page_configuration
from datetime import datetime

set_page_configuration()

current_page = "User Management"
st.header(current_page)

navbar.nav(current_page)

class EnhancedUserManager:
    def __init__(self, db_path='inventory.db'):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
    
    def get_all_users_with_departments(self):
        query = '''
            SELECT u.id, u.username, u.role, 
                   u.created_at, u.last_login, u.isactive,
                   d1.name as parent_department,
                   d2.name as child_department
            FROM users u
            LEFT JOIN departments d2 ON u.department_id = d2.id
            LEFT JOIN departments d1 ON d2.parent_id = d1.id
            ORDER BY u.role, u.username
        '''
        return pd.read_sql_query(query, self.conn)
    
    def register_user(self, username, password, role='User', department_id=None):
        cursor = self.conn.cursor()
        try:
            password_hash, salt = self.hash_password(password)
            cursor.execute(
                '''
                INSERT INTO users (username, password_hash, salt, role, created_at, department_id)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (username, password_hash, salt, role, datetime.now(), department_id))
            self.conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False
        
    def get_parent_departments(self):
        query = "SELECT id, name FROM departments WHERE parent_id IS NULL"
        return pd.read_sql_query(query, self.conn)
    
    def get_child_departments(self, parent_id):
        if not parent_id:
            return pd.DataFrame(columns=['id', 'name'])
        query = "SELECT id, name FROM departments WHERE parent_id = ?"
        return pd.read_sql_query(query, self.conn, params=(parent_id,))
    
    def update_user(self, user_id, username, role, department_id=None):
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                UPDATE users 
                SET username=?, role=?, department_id=?
                WHERE id=?
            ''', (username, role, department_id, user_id))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)
    
    def deactivate_user(self, user_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE users SET isactive=0 WHERE id=?", (user_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)
    
    def activate_user(self, user_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE users SET isactive=1 WHERE id=?", (user_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)

@login_required
def render_admin_page():
    if st.session_state.user_role != 'Admin':
        st.error("You don't have permission to access this page")
        return
    
    if 'user_manager' not in st.session_state:
        st.session_state.user_manager = EnhancedUserManager()
    
    tab1, tab2 = st.tabs(["Manage Users", "Add New User"])

    with tab1:
        #st.subheader("User Management")
        
        df = st.session_state.user_manager.get_all_users_with_departments()
        
        if not df.empty:
            # Display non-editable grid with status indicator
            st.dataframe(
                df[['id', 'username', 'role', 'isactive', 'parent_department', 'child_department']],
                column_config={
                    "id": "ID",
                    "username": "Username",
                    "role": "Role",
                    "isactive": st.column_config.CheckboxColumn(
                        "Active",
                        disabled=True,
                        help="User account status"
                    ),
                    "parent_department": "Parent Department",
                    "child_department": "Child Department"
                },
                hide_index=True,
                use_container_width=True
            )
            
            # Edit user section
            st.subheader("Edit User")
            user_id = st.selectbox(
                "Select User to Edit",
                df['id'],
                format_func=lambda x: f"{df[df['id']==x]['username'].iloc[0]} ({df[df['id']==x]['role'].iloc[0]})"
            )
            
            if user_id:
                user_data = df[df['id'] == user_id].iloc[0]

                # Initialize department variables
                department_id = None
                current_parent = None
                current_child = None

                # Department selection (outside the form for proper cascading)
                if user_data['role'] == "User":
                    st.subheader("Department Assignment")
                    parent_depts = st.session_state.user_manager.get_parent_departments()
                    
                    # Safely get current parent department
                    if not pd.isna(user_data['parent_department']) and not parent_depts.empty:
                        parent_match = parent_depts[parent_depts['name'] == user_data['parent_department']]
                        current_parent = parent_match['id'].iloc[0] if not parent_match.empty else None
                    
                    # Parent department selection
                    selected_parent = st.selectbox(
                        "Parent Department",
                        parent_depts['id'].tolist(),
                        format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                        index=parent_depts['id'].tolist().index(current_parent) if current_parent is not None else 0,
                        key=f"parent_dept_{user_id}"
                    )
                    
                    # Child departments (will update when parent changes)
                    child_depts = st.session_state.user_manager.get_child_departments(selected_parent)
                    
                    # Safely get current child department
                    if not pd.isna(user_data['child_department']) and not child_depts.empty:
                        child_match = child_depts[child_depts['name'] == user_data['child_department']]
                        current_child = child_match['id'].iloc[0] if not child_match.empty else None
                    
                    if not child_depts.empty:
                        # Safely determine index
                        child_index = 0
                        if current_child is not None and current_child in child_depts['id'].tolist():
                            child_index = child_depts['id'].tolist().index(current_child)
                        
                        department_id = st.selectbox(
                            "Child Department",
                            child_depts['id'].tolist(),
                            format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                            index=child_index,
                            key=f"child_dept_{user_id}"
                        )
                    else:
                        st.warning("No child departments available")
                        department_id = None

                with st.form(f"edit_form_{user_id}"):
                    st.markdown("**Basic Information**")
                    new_username = st.text_input("Username", value=user_data['username'])
                    st.text_input("Role", value=user_data['role'], disabled=True)
                    new_role = user_data['role']  # Keep original role
                    
                    # Password change section
                    st.markdown("**Password Change**")
                    change_password = st.checkbox("Change password")
                    new_password = None
                    if change_password:
                        new_password = st.text_input("New Password", type="password")
                        confirm_password = st.text_input("Confirm Password", type="password")
                        if new_password and new_password != confirm_password:
                            st.error("Passwords do not match!")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        if st.form_submit_button("Update"):
                            # Validate password change if requested
                            #print("department_id:", department_id)  # Add this temporarily
                            if change_password and not new_password:
                                st.error("Please enter a new password")
                            else:
                                # Update user information
                                success, message = st.session_state.user_manager.update_user(
                                    user_id=user_id,
                                    username=new_username,
                                    role=new_role,
                                    department_id=department_id if new_role == "User" else None,
                                    new_password=new_password if change_password else None
                                )
                                if success:
                                    st.success("User updated successfully!")
                                    st.rerun()
                                else:
                                    st.error(f"Update failed: {message}")
                    with col2:
                        if st.form_submit_button("Deactivate" if user_data['isactive'] else "Activate"):
                            if user_id == st.session_state.get('user_id'):
                                st.error("You cannot deactivate your own account!")
                            else:
                                if user_data['isactive']:
                                    success, message = st.session_state.user_manager.deactivate_user(user_id)
                                else:
                                    success, message = st.session_state.user_manager.activate_user(user_id)
                                
                                if success:
                                    st.success("User status updated successfully!")
                                    st.rerun()
                                else:
                                    st.error(f"Operation failed: {message}")
        else:
            st.info("No users found")

    with tab2:
        st.subheader("Add New User")
        with st.form("add_user_form"):
            new_username = st.text_input("Username*")
            new_password = st.text_input("Password*", type="password")
            role = st.selectbox("Role*", ["Super User", "Admin", "User"])
            # Submit button
            submit_button = st.form_submit_button(label='Submit')

        # Department selection (only shown for user role)
        department_id = None
        if role == "User":
            st.markdown("**Department Assignment**")
            
            parent_depts = st.session_state.user_manager.get_parent_departments()
            selected_parent = st.selectbox(
                "Parent Department*",
                parent_depts['id'].tolist(),
                index=None,
                placeholder="Select Parent Department",
                format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0]
            )
                
            child_depts = st.session_state.user_manager.get_child_departments(selected_parent)
            if not child_depts.empty:
                department_id = st.selectbox(
                    "Child Department*",
                    child_depts['id'].tolist(),
                    index=None,
                    placeholder="Select Child Department",
                    format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0]
                )
            else:
                st.warning("No child departments available")

            
            
        
            
            # Process the form submission
            if submit_button:
                if new_username and new_password:
                    if role == "User" and not department_id:
                        st.error("Please select a child department for users")
                    else:
                        if st.session_state.user_manager.register_user(
                                username=new_username,
                                password=new_password,
                                role=role,
                                department_id=department_id if role == "User" else None,
                                isactive=True):
                            st.success(f"User {new_username} added successfully")
                            st.rerun()
                        else:
                            st.error("Username already exists")
                    if role == "Super User":
                        if st.session_state.user_manager.register_user(
                                username=new_username,
                                password=new_password,
                                role=role,
                                department_id=department_id if role == "User" else None,
                                isactive=True):
                            st.success(f"User {new_username} added successfully")
                            st.rerun()
                        else:
                            st.error("Username already exists")
                    if role == "Admin":
                        if st.session_state.user_manager.register_user(
                                username=new_username,
                                password=new_password,
                                role=role,
                                department_id=department_id if role == "User" else None,
                                isactive=True):
                            st.success(f"User {new_username} added successfully")
                            st.rerun()
                        else:
                            st.error("Username already exists")
                else:
                    st.error("Please fill in all required fields (marked with *)")

if __name__ == "__main__":
    render_admin_page()

================
File: pyproject.toml
================
[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "barcode>=1.0.4",
    "numpy>=2.2.3",
    "pandas>=2.2.3",
    "pillow>=11.1.0",
    "plotly>=6.0.0",
    "python-barcode>=0.15.1",
    "streamlit-option-menu>=0.4.0",
    "streamlit>=1.43.1",
    "trafilatura>=2.0.0",
]

================
File: user_management.py
================
import sqlite3
import hashlib
import pandas as pd
import secrets
from datetime import datetime
import streamlit as st


class UserManager:

    def __init__(self, db_path='inventory.db'):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.create_users_table()

    def get_all_users_with_departments(self):
        query = '''
            SELECT u.id, u.username, u.role, 
                   u.created_at, u.last_login, u.isactive,
                   d1.name as parent_department,
                   d2.name as child_department
            FROM users u
            LEFT JOIN departments d2 ON u.department_id = d2.id
            LEFT JOIN departments d1 ON d2.parent_id = d1.id
            ORDER BY u.role, u.username
        '''
        return pd.read_sql_query(query, self.conn)
    
    def get_parent_departments(self):
        query = "SELECT id, name FROM departments WHERE parent_id IS NULL"
        return pd.read_sql_query(query, self.conn)
    
    def get_child_departments(self, parent_id):
        if not parent_id:
            return pd.DataFrame(columns=['id', 'name'])
        query = "SELECT id, name FROM departments WHERE parent_id = ?"
        return pd.read_sql_query(query, self.conn, params=(parent_id,))
    
    def update_user(self, user_id, username, role, department_id=None, new_password=None):
        cursor = self.conn.cursor()
        try:
            if new_password:
                # Update password if provided
                password_hash, salt = self.hash_password(new_password)
                cursor.execute(
                    '''
                    UPDATE users 
                    SET username=?, role=?, department_id=?, 
                        password_hash=?, salt=?
                    WHERE id=?
                ''', (username, role, department_id, password_hash, salt, user_id))
            else:
                # Update without changing password
                #print("dept_id:", department_id)  # Add this temporarily
                cursor.execute('''
                    UPDATE users 
                    SET username=?, role=?, department_id=?
                    WHERE id=?
                ''', (username, role, department_id, user_id))
                
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)
    
    def deactivate_user(self, user_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE users SET isactive=0 WHERE id=?", (user_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)
    
    def activate_user(self, user_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE users SET isactive=1 WHERE id=?", (user_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)

    def create_users_table(self):
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    salt TEXT NOT NULL,
                    role TEXT NOT NULL,
                    created_at TIMESTAMP,
                    last_login TIMESTAMP,
                    isactive boolean NOT NULL default 0
                )
            ''')
            self.conn.commit()
            # Create default admin user if not exists
            self.create_default_admin()
        except sqlite3.Error as e:
            print(f"Error creating users table: {e}")
            raise

    def create_default_admin(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM users WHERE username = 'admin'")
        if cursor.fetchone()[0] == 0:
            self.register_user('admin', 'admin123', 'admin')

    def hash_password(self, password, salt=None):
        if salt is None:
            salt = secrets.token_hex(16)
        password_hash = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'),
                                            salt.encode('utf-8'),
                                            100000).hex()
        return password_hash, salt

    def register_user(self, username, password, role='staff', department_id=None, isactive=True):
        cursor = self.conn.cursor()
        try:
            password_hash, salt = self.hash_password(password)
            cursor.execute(
                '''
                INSERT INTO users (username, password_hash, salt, role, created_at, department_id, isactive)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (username, password_hash, salt, role, datetime.now(), department_id, isactive))
            self.conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False

    def verify_user(self, username, password):
        cursor = self.conn.cursor()
        cursor.execute(
            '''
            SELECT password_hash, salt, role, isactive, id FROM users WHERE username = ?
        ''', (username, ))
        result = cursor.fetchone()

        if result:
            stored_hash, salt, role, isactive, user_id = result
            password_hash, _ = self.hash_password(password, salt)
            if password_hash == stored_hash:
                if not isactive:
                    return False, None, None, "Account is inactive. Please contact administrator."
                # Update last login time
                cursor.execute(
                    '''
                    UPDATE users SET last_login = ? WHERE username = ?
                ''', (datetime.now(), username))
                self.conn.commit()
                return True, role, user_id, None
        return False, None, None, "Invalid username or password"

    def get_all_users(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT id, username, role, created_at, last_login 
            FROM users
        ''')
        return cursor.fetchall()

    def update_user_role(self, username, new_role):
        cursor = self.conn.cursor()
        try:
            cursor.execute(
                '''
                UPDATE users SET role = ? WHERE username = ?
            ''', (new_role, username))
            self.conn.commit()
            return True
        except sqlite3.Error:
            return False


def init_session_state():
    """Initialize all required session state variables"""
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
    if 'username' not in st.session_state:
        st.session_state.username = None
    if 'user_role' not in st.session_state:
        st.session_state.user_role = None
    if 'user_id' not in st.session_state:
        st.session_state.user_id = None
    if 'user_manager' not in st.session_state:
        st.session_state.user_manager = UserManager()


def login_required(func):
    """Decorator to require login for accessing pages"""

    def wrapper(*args, **kwargs):
        init_session_state()
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            render_login_page()
            return
        return func(*args, **kwargs)

    return wrapper


def render_login_page():
    st.image("logo.png", width=100)
    st.write("")
    st.title("Ship Inventory Management System")

    # Initialize session state
    init_session_state()

    with st.form("login_form"):
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")

        if st.form_submit_button("Login"):
            if username and password:
                success, role, user_id, error_msg = st.session_state.user_manager.verify_user(
                    username, password)
                if success:
                    st.session_state.authenticated = True
                    st.session_state.username = username
                    st.session_state.user_role = role
                    st.session_state.user_id = user_id
                    st.success(f"Welcome back, {username}!")
                    st.rerun()
                else:
                    st.error(error_msg or "Invalid username or password")
            else:
                st.error("Please enter both username and password")

================
File: pages/reports.py
================
import streamlit as st
from data_manager import DataManager
from utils import create_stock_level_chart, create_transaction_trend, format_transaction_table
import pandas as pd
from user_management import login_required
import navbar
from app_settings import set_page_configuration

set_page_configuration()

current_page = "Reports"
st.header(current_page)

navbar.nav(current_page)


@login_required
def render_reports_page():
    #st.title("Reports and Analytics")

    tab1, tab2, tab3 = st.tabs(
        ["Stock Levels", "Transaction History", "Export Data"])

    with tab1:
        df = st.session_state.data_manager.get_all_parts()
        if not df.empty:
            fig = create_stock_level_chart(df)
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("No inventory data available")

    with tab2:
        days = st.slider("Select time period (days)", 1, 90, 30)
        transactions = st.session_state.data_manager.get_transaction_history(
            days)

        if not transactions.empty:
            fig = create_transaction_trend(transactions)
            st.plotly_chart(fig, use_container_width=True)

            st.subheader("Transaction Details")
            formatted_transactions = format_transaction_table(transactions)
            st.dataframe(formatted_transactions, hide_index=True)
        else:
            st.info("No transaction data available")

    with tab3:
        st.subheader("Export Data")

        export_type = st.radio(
            "Select data to export",
            ["Inventory", "Transactions", "Low Stock Items"])

        if st.button("Generate Export"):
            if export_type == "Inventory":
                data = st.session_state.data_manager.get_all_parts()
            elif export_type == "Transactions":
                data = st.session_state.data_manager.get_transaction_history()
            else:
                data = st.session_state.data_manager.get_low_stock_items()

            if not data.empty:
                csv = data.to_csv(index=False)
                st.download_button(
                    label="Download CSV",
                    data=csv,
                    file_name=f"{export_type.lower()}_export.csv",
                    mime="text/csv")
            else:
                st.warning("No data available for export")


if __name__ == "__main__":
    render_reports_page()

================
File: navbar.py
================
import streamlit as st
from time import sleep
from streamlit_option_menu import option_menu
from user_management import init_session_state, render_login_page
import base64
from data_manager import DataManager

# Initialize session state
init_session_state()

# Define the pages and their file paths
pages = {
    'Home': 'main.py',
    'User Management': 'pages/admin.py',
    'Departments': 'pages/departments.py',
    'Analytics': 'pages/analytics.py',
    'Inventory': 'pages/inventory.py',
    'Operations': 'pages/operations.py',
    'Reports': 'pages/reports.py',
    'Logout': 'main.py'
}

icons = [
    'house', 'people-fill', 'building', 'graph-up-arrow', 'gear', 'toggles',
    'clipboard2-data', 'box-arrow-right'
]

# Create a list of the page names
page_list = list(pages.keys())


def nav(current_page=page_list[0]):
    # Initialize session state if not already done
    if 'authenticated' not in st.session_state:
        init_session_state()

    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()

    with st.sidebar:
        #st.image("logo.png", width=100)
        add_logo()
        st.write("")

        if st.session_state.authenticated:
            st.write(f"Logged in as: {st.session_state.username}")
            st.write(f"Role: {st.session_state.user_role}")

            # Safely check for low stock items
            if 'data_manager' in st.session_state:
                try:
                    # Alert Section in Sidebar
                    low_stock = st.session_state.data_manager.get_low_stock_items()
                    if not low_stock.empty:
                        st.error(
                            f"ðŸš¨ {len(low_stock)} items below minimum stock level!")
                        with st.expander("View Low Stock Alerts"):
                            for _, item in low_stock.iterrows():
                                st.warning(f"""
                                    **{item['name']}**
                                    - Current: {item['quantity']}
                                    - Minimum: {item['min_order_level']}
                                    - Order Quantity: {item['min_order_quantity']}
                                """)
                except Exception as e:
                    st.error(f"Error checking stock levels: {str(e)}")

            user_role = st.session_state.get('user_role', 'user')
            #print("user_role:", user_role)  # Add this temporarily
            if user_role == 'Super User':
                visible_pages = list(pages.keys())
                visible_icons = icons
            elif user_role == 'Admin':
                # Exclude User Management and Departments
                visible_pages = [p for p in pages.keys() 
                            if p not in [ 'Departments']]
                visible_icons = [icon for icon, p in zip(icons, pages.keys())
                            if p not in [ 'Departments']]
            else:  # Regular user
                visible_pages = ['Inventory', 'Reports', 'Logout']
                visible_icons = ['gear', 'clipboard2-data', 'box-arrow-right']

            #print("visible_pages list 2:", visible_pages)  # Add this temporarily
            # Create the menu
            if visible_pages:
                selected = option_menu(
                    "Menu",
                    visible_pages,
                    icons=visible_icons,
                    default_index=visible_pages.index(current_page) if current_page in visible_pages else 0,
                    orientation="vertical"
                )
                
                # Handle logout
                if selected == "Logout":
                    st.session_state.clear()  # Clear all session state
                    st.rerun()   # Rerun to show login page

            if current_page != selected:
                st.switch_page(pages[selected])
        #else:
            # Show login page without sidebar
            #st.set_page_config(layout="centered")
            #render_login_page()


def make_sidebar(current_page=page_list[0]):

    # Initialize session state if not already done
    if 'authenticated' not in st.session_state:
        init_session_state()

    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()

    with st.sidebar:
        #st.image("logo.png", width=100)
        add_logo()
        st.write("")
        #print("visible_pages list:")  # Add this temporarily
        if st.session_state.authenticated:
            st.write(f"Logged in as: {st.session_state.username}")
            st.write(f"Role: {st.session_state.user_role}")
            #print("Page list:", page_list)  # Add this temporarily
            
            # Safely check for low stock items
            if 'data_manager' in st.session_state:
                try:
                    # Alert Section in Sidebar
                    low_stock = st.session_state.data_manager.get_low_stock_items()
                    if not low_stock.empty:
                        st.error(
                            f"ðŸš¨ {len(low_stock)} items below minimum stock level!")
                        with st.expander("View Low Stock Alerts"):
                            for _, item in low_stock.iterrows():
                                st.warning(f"""
                                    **{item['name']}**
                                    - Current: {item['quantity']}
                                    - Minimum: {item['min_order_level']}
                                    - Order Quantity: {item['min_order_quantity']}
                                """)
                except Exception as e:
                    st.error(f"Error checking stock levels: {str(e)}")

            user_role = st.session_state.get('user_role', 'user')
            #print("user_role:", user_role)  # Add this temporarily
            if user_role == 'Super User':
                visible_pages = list(pages.keys())
                visible_icons = icons
            elif user_role == 'Admin':
                # Exclude User Management and Departments
                visible_pages = [p for p in pages.keys() 
                            if p not in [ 'Departments']]
                visible_icons = [icon for icon, p in zip(icons, pages.keys())
                            if p not in [ 'Departments']]
            else:  # Regular user
                visible_pages = ['Inventory', 'Reports', 'Logout']
                visible_icons = ['gear', 'clipboard2-data', 'box-arrow-right']

            #print("visible_pages list 2:", visible_pages)  # Add this temporarily
            # Create the menu
            if visible_pages:
                selected = option_menu(
                    "Menu",
                    visible_pages,
                    icons=visible_icons,
                    default_index=visible_pages.index(current_page) if current_page in visible_pages else 0,
                    orientation="vertical"
                )
                
                # Handle logout
                if selected == "Logout":
                    st.session_state.clear()  # Clear all session state
                    st.rerun()   # Rerun to show login page

            if current_page != selected:
                st.switch_page(pages[selected])
        else:
            # Show login page without sidebar
            st.set_page_config(layout="centered")
            render_login_page()

            

        #elif current_page != p:
        # If anyone tries to access a secret page without being logged in,
        # redirect them to the login page
        #st.switch_page("login.py")
        #   render_login_page()


def logout():
    st.session_state.logged_in = False
    st.info("Logged out successfully!")
    sleep(0.5)
    render_login_page()

def get_base64_of_bin_file(png_file: str) -> str:
    with open(png_file, "rb") as f:
        return base64.b64encode(f.read()).decode()

@st.cache_resource
def build_markup_for_logo(png_file: str) -> str:
    binary_string = get_base64_of_bin_file(png_file)
    return f"""
            <style>
                [data-testid="stSidebarHeader"] {{
                    background-image: url("data:image/png;base64,{binary_string}");
                    background-repeat: no-repeat;
                    background-size: contain;
                    background-position: top center;
                }}
            </style>
            """

def add_logo():
    st.markdown(
        build_markup_for_logo("logo.png"),
        unsafe_allow_html=True,
    )

#st.switch_page("login.py")

================
File: pages/analytics.py
================
import streamlit as st
import pandas as pd
from utils import (create_demand_forecast_chart, calculate_reorder_point,
                   calculate_stock_turnover)
from user_management import login_required, init_session_state, render_login_page
import navbar
from app_settings import set_page_configuration

set_page_configuration()

current_page = "Analytics"
st.header(current_page)

navbar.nav(current_page)


@login_required
def render_analytics_page():
    #st.title("Advanced Analytics and Forecasting")

    # Get data
    df = st.session_state.data_manager.get_all_parts()
    transactions = st.session_state.data_manager.get_transaction_history(
        days=90)

    if df.empty:
        st.warning("No inventory data available for analysis")
        return

    # Part selection
    selected_part = st.selectbox("Select Part for Analysis",
                                 df['name'].tolist())

    if selected_part:
        part_data = df[df['name'] == selected_part].iloc[0]
        part_id = part_data['id']

        # Display current metrics
        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric(
                "Current Stock",
                int(part_data['quantity'])  # Convert to Python int
            )

        with col2:
            reorder_point = calculate_reorder_point(transactions, part_id)
            st.metric(
                "Suggested Reorder Point",
                reorder_point,
                delta=int(part_data['quantity']) -
                reorder_point  # Convert to Python int
            )

        with col3:
            turnover = calculate_stock_turnover(
                transactions[transactions['part_id'] == part_id],
                int(part_data['quantity'])  # Convert to Python int
            )
            st.metric("Stock Turnover Rate", f"{turnover}/year")

        # Demand Forecast Chart
        st.subheader("Demand Forecast Analysis")
        forecast_days = st.slider("Forecast Period (Days)",
                                  min_value=7,
                                  max_value=90,
                                  value=30)

        forecast_chart = create_demand_forecast_chart(
            transactions, part_id, days_to_forecast=forecast_days)

        if forecast_chart:
            st.plotly_chart(forecast_chart, use_container_width=True)

            # Analysis insights
            st.subheader("Inventory Insights")

            # Stock status
            if part_data['quantity'] <= reorder_point:
                st.warning(f"""
                    ðŸš¨ Stock Alert: Current stock ({int(part_data['quantity'])}) is at or below
                    the recommended reorder point ({reorder_point}).
                    Consider restocking soon.
                """)

            # Turnover analysis
            if turnover < 1:
                st.info("ðŸ’¡ Low turnover rate indicates slow-moving inventory.")
            elif turnover > 12:
                st.info(
                    "ðŸ’¡ High turnover rate indicates fast-moving inventory.")

            # Forecast interpretation
            st.info("""
                ðŸ“Š The forecast shown above uses:
                - 7-day moving average (dashed line)
                - Exponential smoothing (dotted line)
                - Trend-based projection (dash-dot line)

                The forecast considers historical demand patterns and recent trends.
            """)
        else:
            st.info("Insufficient transaction history for forecasting")


if __name__ == "__main__":
    if not st.session_state.authenticated:
        render_login_page()
    else:
        render_analytics_page()

================
File: pages/inventory.py
================
import streamlit as st
import pandas as pd  # Add this import at the top
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from user_management import login_required
import navbar
from datetime import datetime
from app_settings import set_page_configuration

set_page_configuration()

current_page = "Inventory"
st.header(current_page)

navbar.nav(current_page)

class EnhancedDataManager(DataManager):

    def get_parent_departments(self):
        """Get all parent departments"""
        query = "SELECT id, name FROM departments WHERE parent_id IS NULL"
        return pd.read_sql_query(query, self.conn)

    def get_child_departments(self, parent_id):
        """Get child departments for a given parent"""
        if not parent_id:
            return pd.DataFrame(columns=['id', 'name'])
        query = "SELECT id, name FROM departments WHERE parent_id = ?"
        return pd.read_sql_query(query, self.conn, params=(parent_id,))
    
    def bulk_import_spare_parts(self, df, department_id):
        """Bulk import spare parts from DataFrame with department assignment"""
        cursor = self.conn.cursor()
        try:
            records = df.to_dict('records')
            cursor.execute("BEGIN TRANSACTION")
            
            for record in records:
                # Generate barcode if not provided
                if 'barcode' not in record or pd.isna(record.get('barcode')) or not record.get('barcode'):
                    record['barcode'] = BarcodeHandler.generate_unique_barcode()
                
                # Set default values
                record['department_id'] = department_id
                record['min_order_level'] = record.get('min_order_level', 0)
                record['min_order_quantity'] = record.get('min_order_quantity', 1)
                record['compartment_no'] = record.get('compartment_no', '')
                record['last_updated'] = datetime.now()
                
                # Ensure all required fields have values
                record['part_number'] = str(record['part_number'])
                record['name'] = str(record['name'])
                record['quantity'] = int(record['quantity'])
                record['line_no'] = int(record.get('line_no', 0))
                record['yard_no'] = int(record.get('yard_no', 0))
                
                cursor.execute('''
                    INSERT OR REPLACE INTO spare_parts (
                        part_number, name, description, quantity,
                        line_no, yard_no, page_no, order_no,
                        material_code, ilms_code, item_denomination,
                        mustered, department_id, compartment_no,
                        box_no, remark, min_order_level,
                        min_order_quantity, barcode, last_updated
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    record['part_number'],
                    record['name'],
                    record.get('description', ''),
                    record['quantity'],
                    record['line_no'],
                    record['yard_no'],
                    str(record.get('page_no', '')),
                    str(record.get('order_no', '')),
                    str(record.get('material_code', '')),
                    str(record.get('ilms_code', '')),
                    str(record.get('item_denomination', '')),
                    bool(record.get('mustered', False)),
                    record['department_id'],
                    str(record.get('compartment_no', '')),
                    str(record.get('box_no', '')),
                    str(record.get('remark', '')),
                    int(record.get('min_order_level', 0)),
                    int(record.get('min_order_quantity', 1)),
                    record['barcode'],
                    record['last_updated']
                ))
            
            self.conn.commit()
            return True, f"Successfully imported {len(records)} records to selected department"
        except Exception as e:
            self.conn.rollback()
            return False, f"Error during import: {str(e)}"
        finally:
            cursor.close()

@login_required
def render_inventory_page():
     
    # Initialize enhanced data manager
    if 'enhanced_data_manager' not in st.session_state:
        st.session_state.enhanced_data_manager = EnhancedDataManager()
        
    # Initialize session state for department selection
    if 'selected_parent_dept' not in st.session_state:
        st.session_state.selected_parent_dept = None
    if 'selected_child_dept' not in st.session_state:
        st.session_state.selected_child_dept = None

    if st.session_state.user_role == 'User':
        tab1 = st.tabs(["View Inventory"])
    else:
        tab1, tab2, tab3 = st.tabs(["View Inventory", "Add New Part", "Bulk Import"])

    with tab1:
        df = st.session_state.data_manager.get_all_parts()

        # Search and filter
        search_term = st.text_input("Search parts by name, part_number, box_no or barcode")
        if search_term:
            df = df[df['name'].str.contains(search_term, case=False) |
                    df['part_number'].str.contains(search_term, case=False) |
                    df['barcode'].str.contains(search_term, case=False) |
                    df['box_no'].str.contains(search_term, case=False)]

        st.dataframe(df[[
            'part_number', 'name', 'quantity', 'parent_department', 'child_department', 
            'line_no', 'yard_no', 'page_no', 'order_no',
            'material_code', 'ilms_code', 'item_denomination',
            'mustered', 'compartment_no', 'box_no', 'remark',
            'min_order_level', 'barcode',
            'status', 'last_maintenance_date',
            'next_maintenance_date'
        ]],
        column_config={
            "mustered": st.column_config.CheckboxColumn("Mustered"),
            "quantity": st.column_config.NumberColumn("Qty", format="%d")
        },
        use_container_width=True,
        hide_index=True)

        if st.session_state.user_role in ['Admin', 'Super User']:
            # Edit part
            if not df.empty:
                part_to_edit = st.selectbox("Select part to edit",
                                            df['name'].tolist())

                if part_to_edit:
                    part_data = df[df['name'] == part_to_edit].iloc[0]
                    with st.form("edit_part_form"):
                        new_quantity = st.number_input("Quantity",
                                                    value=int(
                                                        part_data['quantity']),
                                                    min_value=0)
                        new_min_level = st.number_input(
                            "Minimum Order Level",
                            value=int(part_data['min_order_level']),
                            min_value=0)
                        new_min_quantity = st.number_input(
                            "Minimum Order Quantity",
                            value=int(part_data['min_order_quantity']),
                            min_value=1)                    
                        new_status = st.selectbox(
                            "Status",
                            ["Operational", "Under Maintenance", "In Store"],
                            index=["Operational", "Under Maintenance",
                                "In Store"].index(part_data['status']))
                        new_last_maintenance_date = st.date_input(
                            "Last Maintenance Date",
                            value=datetime.strptime(
                                part_data['last_maintenance_date'],
                                '%Y-%m-%d').date())
                        new_next_maintenance_date = st.date_input(
                            "Next Maintenance Date",
                            value=datetime.strptime(
                                part_data['next_maintenance_date'],
                                '%Y-%m-%d').date())

                        if st.form_submit_button("Update Part"):
                            if new_last_maintenance_date > datetime.now().date():
                                st.error(
                                    "Last Maintenance Date should not be greater than the current date."
                                )
                            elif new_next_maintenance_date <= datetime.now().date(
                            ):
                                st.error(
                                    "Next Maintenance Date should be greater than the current date."
                                )
                            else:
                                st.session_state.data_manager.update_spare_part(
                                    part_data['id'], {
                                        'name':
                                        part_data['name'],
                                        'description':
                                        part_data['description'],
                                        'quantity':
                                        new_quantity,
                                        'min_order_level':
                                        new_min_level,
                                        'min_order_quantity':
                                        new_min_quantity,                                   
                                        'status':
                                        new_status,
                                        'last_maintenance_date':
                                        new_last_maintenance_date.strftime(
                                            '%Y-%m-%d'),
                                        'next_maintenance_date':
                                        new_next_maintenance_date.strftime(
                                            '%Y-%m-%d')
                                    })
                                st.success("Part updated successfully!")
                                st.rerun()

    if st.session_state.user_role in ['Admin', 'Super User']:
        with tab2:
            # Department selection
            parent_depts = st.session_state.enhanced_data_manager.get_parent_departments()
            if parent_depts.empty:
                st.error("No departments found. Please create departments first.")
                return
            
            selected_parent = st.selectbox(
                "Select Parent Department*",
                parent_depts['id'].tolist(),
                index=None,
                placeholder="Select Parent Department",
                format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                key = "AddParentDept"
            )
            
            child_depts = st.session_state.enhanced_data_manager.get_child_departments(selected_parent)
            if child_depts.empty:
                st.error("No child departments found for selected parent.")
                return
            
            selected_child = st.selectbox(
                "Select Child Department*",
                child_depts['id'].tolist(),
                index=None,
                placeholder="Select Child Department",
                format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                key = "AddChildDept"
            )

            with st.form("add_part_form"):
                
                cols = st.columns(3)

                with cols[0]:
                    part_number = st.text_input("Part Number*", max_chars=20)
                    name = st.text_input("Part Name*", max_chars=100)
                    compartment_no = st.text_input("Compartment No", max_chars=20)
                    box_no = st.text_input("Box No", max_chars=20)                
                    quantity = st.number_input("Initial Quantity*", min_value=0)
                    line_no = st.number_input("Line No*", min_value=1)
                    yard_no = st.number_input("Yard No*", min_value=1)
                    
                with cols[1]:
                    page_no = st.text_input("Page No", max_chars=20)
                    order_no = st.text_input("Order No", max_chars=20)
                    material_code = st.text_input("Material Code", max_chars=50)
                    ilms_code = st.text_input("ILMS Code", max_chars=50)
                    item_denomination = st.text_input("Item Denomination", max_chars=100)
                    min_order_level = st.number_input("Minimum Order Level", min_value=0)
                    min_order_quantity = st.number_input("Minimum Order Quantity", min_value=1) 
                    
                with cols[2]:
                    last_maintenance_date = st.date_input("Last Maintenance Date")     
                    next_maintenance_date = st.date_input("Next Maintenance Date")
                    status = st.selectbox("Status", ["Operational", "Under Maintenance", "In Store"])                
                    description = st.text_area("Description")
                    remark = st.text_area("Remarks")
                    mustered = st.checkbox("Mustered")
                    

                if st.form_submit_button("Add Part"):
                    if part_number and name:
                        if last_maintenance_date > datetime.now().date():
                            st.error(
                                "Last Maintenance Date should not be greater than the current date."
                            )
                        elif next_maintenance_date <= datetime.now().date():
                            st.error(
                                "Next Maintenance Date should be greater than the current date."
                            )
                        else:
                            barcode = st.session_state.barcode_handler.generate_unique_barcode(
                            )
                            success = st.session_state.data_manager.add_spare_part(
                                {
                                    'part_number': part_number,
                                    'name': name,
                                    'description': description,
                                    'quantity': quantity,
                                    'line_no': line_no,
                                    'yard_no': yard_no,
                                    'page_no': page_no,
                                    'order_no': order_no,
                                    'material_code': material_code,
                                    'ilms_code': ilms_code,
                                    'item_denomination': item_denomination,
                                    'mustered': mustered,
                                    'department_id': selected_child,
                                    'compartment_no': compartment_no,
                                    'box_no': box_no,
                                    'remark': remark,
                                    'min_order_level': min_order_level,
                                    'min_order_quantity': min_order_quantity,
                                    'barcode': barcode,                                
                                    'status': status,
                                    'last_maintenance_date': last_maintenance_date.strftime('%Y-%m-%d'),
                                    'next_maintenance_date': next_maintenance_date.strftime('%Y-%m-%d')
                                })

                            if success:
                                st.success("Part added successfully!")
                                st.markdown(f"Generated barcode: `{barcode}`")
                                barcode_image = st.session_state.barcode_handler.generate_barcode(
                                    barcode)
                                st.image(f"data:image/png;base64,{barcode_image}")
                            else:
                                st.error("Part number already exists!")
                    else:
                        st.error("Part number and name are required!")

        with tab3:
            bulk_import_section()

def bulk_import_section():
    """Bulk import from CSV with department selection"""
    st.subheader("Bulk Import from CSV")
    
    # Step 1: Department Selection
    st.markdown("### Step 1: Select Department")
    
    parent_depts = st.session_state.enhanced_data_manager.get_parent_departments()
    if parent_depts.empty:
        st.error("No departments found. Please create departments first.")
        return
    
    selected_parent = st.selectbox(
        "Select Parent Department*",
        parent_depts['id'].tolist(),
        index=None,
        placeholder="Select Parent Department",
        format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0]
    )
    
    child_depts = st.session_state.enhanced_data_manager.get_child_departments(selected_parent)
    if child_depts.empty:
        st.error("No child departments found for selected parent.")
        return
    
    selected_child = st.selectbox(
        "Select Child Department*",
        child_depts['id'].tolist(),
        index=None,
        placeholder="Select Child Department",
        format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0]
    )
    
    # Step 2: File Upload
    st.markdown("### Step 2: Upload CSV File")
    uploaded_file = st.file_uploader(
        "Choose a CSV file",
        type=["csv"],
        help="Upload a CSV file with spare parts data"
    )
    
    if uploaded_file is not None and selected_child:
        try:
            # Read the uploaded file
            df = pd.read_csv(uploaded_file)
            
            # Validate required columns
            required_columns = [
                'part_number', 'name', 'quantity',
                'line_no', 'yard_no'
            ]
            
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                st.error(f"Missing required columns: {', '.join(missing_columns)}")
                return
            
            # Data cleaning and type conversion
            df_clean = df.copy()
            
            # Handle numeric columns - fill NaN with 0 and convert to int
            numeric_cols = ['quantity', 'line_no', 'yard_no']
            for col in numeric_cols:
                if col in df_clean.columns:
                    df_clean[col] = df_clean[col].fillna(0).astype(int)
            
            # Handle text columns - fill NaN with empty string
            text_cols = [
                'page_no', 'order_no', 'material_code', 
                'ilms_code', 'item_denomination', 'box_no', 'Remark'
            ]
            for col in text_cols:
                if col in df_clean.columns:
                    df_clean[col] = df_clean[col].fillna('').astype(str)
            
            # Handle boolean column
            if 'mustered' in df_clean.columns:
                df_clean['mustered'] = df_clean['mustered'].fillna(False).astype(bool)
            
            # Show preview with department info
            st.subheader("Import Preview")
            st.info(f"All items will be assigned to: {child_depts[child_depts['id'] == selected_child]['name'].iloc[0]}")
            
            preview_df = df_clean.head().copy()
            preview_df['assigned_department'] = child_depts[child_depts['id'] == selected_child]['name'].iloc[0]
            st.dataframe(preview_df, hide_index=True)
            
            # Map CSV columns to database columns
            column_mapping = {
                'part_number': 'part_number',
                'name': 'name',
                'description': 'description',
                'quantity': 'quantity',
                'line_no': 'line_no',
                'yard_no': 'yard_no',
                'page_no': 'page_no',
                'order_no': 'order_no',
                'material_code': 'material_code',
                'ilms_code': 'ilms_code',
                'item_denomination': 'item_denomination',
                'mustered': 'mustered',
                'box_no': 'box_no',
                'Remark': 'remark',
                'barcode': 'barcode'
            }
            
            df_import = df_clean.rename(columns=column_mapping)
            
            # Step 3: Import Confirmation
            st.markdown("### Step 3: Confirm Import")
            if st.button(f"Import {len(df_clean)} Records"):
                with st.spinner(f"Importing {len(df_clean)} records..."):
                    success, message = st.session_state.enhanced_data_manager.bulk_import_spare_parts(
                        df_import, selected_child
                    )
                    if success:
                        st.success(message)
                        st.rerun()
                    else:
                        st.error(message)
                        
        except Exception as e:
            st.error(f"Error processing file: {str(e)}")

if __name__ == "__main__":
    render_inventory_page()

================
File: .streamlit/config.toml
================
[server]
headless = true
address = "0.0.0.0"
port = 8501
#port = 8501 for hosting on streamlit community cloud
#port = 5000 for local development

[theme]
primaryColor = "#0066cc"
backgroundColor = "#ffffff"
secondaryBackgroundColor = "#f0f2f6"
textColor = "#262730"

[ui]
hideTopBar = true

[client]
showSidebarNavigation = false
toolbarMode = "minimal"

================
File: data_manager.py
================
import sqlite3
from contextlib import contextmanager
import pandas as pd
from datetime import datetime
import os


class DataManager:

    def __init__(self):
        # Ensure database directory exists
        self.db_path = 'inventory.db'
        self.conn = sqlite3.connect(self.db_path, check_same_thread=False,
                               timeout=10)
        self.create_tables()
        print(f"Connected to database at {self.db_path}")

    @contextmanager
    def get_cursor(self):
        cursor = self.conn_pool.cursor()
        try:
            yield cursor
        finally:
            cursor.close()

    def create_tables(self):
        cursor = self.conn.cursor()
        try:
            # Create departments table (add this)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS departments (
                    id INTEGER PRIMARY KEY,
                    code TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    parent_id INTEGER,
                    FOREIGN KEY (parent_id) REFERENCES departments (id)
                )
            ''')

            # Create spare parts table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS spare_parts (
                    id INTEGER PRIMARY KEY,
                    part_number TEXT UNIQUE,
                    name TEXT,
                    description TEXT,
                    quantity INTEGER,
                    line_no INTEGER,
                    yard_no INTEGER,
                    page_no TEXT,
                    order_no TEXT,
                    material_code TEXT,
                    ilms_code TEXT,
                    item_denomination TEXT,
                    mustered BOOLEAN,
                    department_id INTEGER,
                    compartment_no TEXT,
                    box_no TEXT,
                    remark TEXT,
                    min_order_level INTEGER,
                    min_order_quantity INTEGER,
                    barcode TEXT UNIQUE,
                    last_updated TIMESTAMP
                )
            ''')

            # Create transactions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS transactions (
                    id INTEGER PRIMARY KEY,
                    part_id INTEGER,
                    transaction_type TEXT,
                    quantity INTEGER,
                    timestamp TIMESTAMP,
                    FOREIGN KEY (part_id) REFERENCES spare_parts (id)
                )
            ''')

            self.conn.commit()
            print("Database tables created successfully")
        except sqlite3.Error as e:
            print(f"Error creating tables: {e}")
            raise

    def add_spare_part(self, part_data):
        cursor = self.conn.cursor()
        try:
            cursor.execute(
                '''
                INSERT INTO spare_parts (part_number, name, description, quantity,
                line_no, yard_no, page_no, order_no, material_code, ilms_code, item_denomination,
                mustered, department_id, compartment_no,  box_no, remark, 
                min_order_level, min_order_quantity, barcode, last_updated, status,
                last_maintenance_date, next_maintenance_date)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''',
                (part_data['part_number'], part_data['name'],
                part_data['description'], part_data['quantity'],
                part_data['line_no'], part_data['yard_no'],
                part_data['page_no'], part_data['order_no'],
                part_data['material_code'], part_data['ilms_code'],
                part_data['item_denomination'], part_data['mustered'],
                part_data['department_id'], part_data['compartment_no'],
                part_data['box_no'], part_data['remark'],
                part_data['min_order_level'], part_data['min_order_quantity'],
                part_data['barcode'], datetime.now(), 
                part_data['status'], part_data['last_maintenance_date'],
                part_data['next_maintenance_date']))
            self.conn.commit()
            cursor.close()  # Explicitly close cursor
            return True
        except sqlite3.IntegrityError:
            return False
        except sqlite3.Error as e:
            print(f"Error adding spare part: {e}")
            return False

    def update_spare_part(self, part_id, part_data):
        cursor = self.conn.cursor()
        cursor.execute(
            '''
            UPDATE spare_parts 
            SET name=?, description=?, quantity=?, min_order_level=?,
                min_order_quantity=?, last_updated=?, location=?, status=?,
                last_maintenance_date=?, next_maintenance_date=?
            WHERE id=?
        ''', (part_data['name'], part_data['description'],
            part_data['quantity'], part_data['min_order_level'],
            part_data['min_order_quantity'], datetime.now(), part_data['location'],
            part_data['status'], part_data['last_maintenance_date'],
            part_data['next_maintenance_date'], part_id))
        self.conn.commit()
        cursor.close()  # Explicitly close cursor

    def get_all_parts(self):
        try:
            cursor = self.conn.cursor()
            query = '''
                SELECT s.*, 
                    dp.name as parent_department,
                    dc.name as child_department
                FROM spare_parts s
                LEFT JOIN departments dc ON s.department_id = dc.id
                LEFT JOIN departments dp ON dc.parent_id = dp.id
            '''
            df = pd.read_sql_query(query, self.conn)
            cursor.close()  # Explicitly close cursor
            return df
        except pd.io.sql.DatabaseError as e:
            print(f"Error retrieving parts: {e}")
            return pd.DataFrame()

    def get_part_by_id(self, part_id):
        try:
            cursor = self.conn.cursor()
            df = pd.read_sql_query(
                f"SELECT * FROM spare_parts WHERE id= {part_id}", self.conn)
            cursor.close()  # Explicitly close cursor
            if df.empty:
                print(f"No part found with ID {part_id}")
                return None
            return df
        except pd.io.sql.DatabaseError as e:
            print(f"Error retrieving part {part_id}: {e}")
            return None

    def get_low_stock_items(self):
        try:
            return pd.read_sql_query(
                "SELECT * FROM spare_parts WHERE quantity <= min_order_level",
                self.conn)
        except pd.io.sql.DatabaseError as e:
            print(f"Error retrieving low stock items: {e}")
            return pd.DataFrame()

    def record_transaction(self, part_id, transaction_type, quantity):
        cursor = self.conn.cursor()
        try:
            # First verify the part exists and has enough stock
            # print(f"recording transaction: {part_id}")  # hari
            part_df = self.get_part_by_id(part_id)
            if part_df is None or part_df.empty:
                raise ValueError(f"Part with ID {part_id} not found")

            part = part_df.iloc[0]
            current_quantity = int(part['quantity'])
            selected_part = int(part_id)

            if transaction_type == 'check_out' and current_quantity < quantity:
                raise ValueError(
                    f"Insufficient stock. Available: {current_quantity}, Requested: {quantity}"
                )

            # Record the transaction
            cursor.execute(
                '''
                INSERT INTO transactions (part_id, transaction_type, quantity, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (selected_part, transaction_type, quantity, datetime.now()))

            print(f"Recorded transaction: {transaction_type}")

            # Update stock quantity
            update_quantity = -quantity if transaction_type == 'check_out' else quantity
            cursor.execute(
                '''
                UPDATE spare_parts 
                SET quantity = quantity + ?, last_updated = ?
                WHERE id = ?
            ''', (update_quantity, datetime.now(), selected_part))

            self.conn.commit()
            return True, None  # Success, no error message
        except (sqlite3.Error, ValueError) as e:
            print(f"Error recording transaction: {e}")
            self.conn.rollback()
            return False, str(e)  # Return error status and message

    def get_transaction_history(self, days=30):
        query = '''
            SELECT t.*, sp.name, sp.part_number
            FROM transactions t
            JOIN spare_parts sp ON t.part_id = sp.id
            WHERE t.timestamp >= date('now', ?)
        '''
        try:
            return pd.read_sql_query(query,
                                     self.conn,
                                     params=[f'-{days} days'])
        except pd.io.sql.DatabaseError as e:
            print(f"Error retrieving transaction history: {e}")
            return pd.DataFrame()

================
File: main.py
================
import streamlit as st
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from user_management import login_required, init_session_state, render_login_page
from navbar import make_sidebar
from app_settings import set_page_configuration

set_page_configuration()



# Initialize alerts in session state
if 'alerts' not in st.session_state:
    st.session_state.alerts = []


@login_required
def main():

    # Initialize session state
    init_session_state()

    # Set page config (will be overridden by navbar if needed)
    #st.set_page_config(layout="centered")

    #if not st.session_state.get('authenticated', False):
    #    render_login_page()

    # Initialize data manager and barcode handler if needed
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    if 'barcode_handler' not in st.session_state:
        st.session_state.barcode_handler = BarcodeHandler()

    st.title("Ship Inventory Management System")

    # Show user info in sidebar
    with st.sidebar:
        #st.write(f"Logged in as: {st.session_state.username}")
        #st.write(f"Role: {st.session_state.user_role}")

        # Alert Section in Sidebar
        #low_stock = st.session_state.data_manager.get_low_stock_items()
        #if not low_stock.empty:
        #    st.error(f"ðŸš¨ {len(low_stock)} items below minimum stock level!")
        #    with st.expander("View Low Stock Alerts"):
        #        for _, item in low_stock.iterrows():
        #            st.warning(f"""
        #                **{item['name']}**
        #                - Current: {item['quantity']}
        #                - Minimum: {item['min_order_level']}
        #                - Order Quantity: {item['min_order_quantity']}
        #            """)

        make_sidebar()

        #if st.button("Logout"):
        #    st.session_state.authenticated = False
        #    st.session_state.username = None
        #    st.session_state.user_role = None
        #    st.rerun()

    # Dashboard layout
    col1, col2 = st.columns(2)

    with col1:
        low_stock = st.session_state.data_manager.get_low_stock_items()
        st.subheader("Inventory Overview")
        df = st.session_state.data_manager.get_all_parts()
        total_parts = len(df)
        low_stock_count = len(low_stock)

        st.metric("Total Parts",
                  total_parts,
                  help="Total number of unique parts in inventory")
        st.metric("Low Stock Items",
                  low_stock_count,
                  delta=low_stock_count,
                  delta_color="inverse",
                  help="Number of items below minimum order level")

    with col2:
        st.subheader("Quick Actions")
        if st.button("View Low Stock Items"):
            low_stock = st.session_state.data_manager.get_low_stock_items()
            if not low_stock.empty:
                st.dataframe(low_stock[[
                    'name', 'part_number', 'quantity', 'min_order_level'
                ]],
                             hide_index=True)

                # Download low stock report
                csv = low_stock.to_csv(index=False)
                st.download_button(
                    "Download Low Stock Report",
                    csv,
                    "low_stock_report.csv",
                    "text/csv",
                    help="Download a CSV report of all low stock items")
            else:
                st.success("All items are above minimum stock levels")

    # Recent Transactions
    st.subheader("Recent Transactions")
    recent_transactions = st.session_state.data_manager.get_transaction_history(
        days=7)
    if not recent_transactions.empty:
        st.dataframe(recent_transactions[[
            'timestamp', 'name', 'transaction_type', 'quantity'
        ]],
                     hide_index=True)
    else:
        st.info("No recent transactions found")


if __name__ == "__main__":
    if 'authenticated' not in st.session_state:
        render_login_page()
    else:
        main()

================
File: pages/operations.py
================
import streamlit as st
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from user_management import login_required
from datetime import datetime
import navbar
from app_settings import set_page_configuration

set_page_configuration()

current_page = "Operations"
st.header(current_page)

navbar.nav(current_page)


@login_required
def render_operations_page():
    # Initialize session state if needed
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    if 'barcode_handler' not in st.session_state:
        st.session_state.barcode_handler = BarcodeHandler()
    if 'last_scans' not in st.session_state:
        st.session_state.last_scans = []

    #st.title("Operations")

    # Show any active alerts
    low_stock = st.session_state.data_manager.get_low_stock_items()
    if not low_stock.empty:
        with st.expander("ðŸš¨ Low Stock Alerts", expanded=True):
            st.warning(f"{len(low_stock)} items need attention!")
            for _, item in low_stock.iterrows():
                st.error(f"""
                    **{item['name']}** (Part #{item['part_number']})
                    - Current Stock: {item['quantity']}
                    - Minimum Level: {item['min_order_level']}
                    - Suggested Order: {item['min_order_quantity']}
                """)

    tab1, tab2, tab3 = st.tabs(
        ["Barcode Scanner", "Check-In/Check-Out", "Issue Parts"])

    with tab1:
        st.subheader("Barcode Scanner Interface")
        st.info("""
        ðŸ“± Use this interface with a physical barcode scanner or enter the barcode manually.
        The scanner should work automatically when you scan a barcode.
        """)

        col1, col2 = st.columns([2, 1])
        with col1:
            barcode_input = st.text_input("Scan or Enter Barcode",
                                          key="barcode_scanner",
                                          placeholder="SP00509457")

            if barcode_input:
                is_valid, cleaned_barcode = st.session_state.barcode_handler.validate_barcode(
                    barcode_input)
                if is_valid:
                    success, part = st.session_state.barcode_handler.get_part_by_barcode(
                        st.session_state.data_manager, cleaned_barcode)
                    if success:
                        st.success("Part found!")

                        # Show alert if item is low on stock
                        if part['quantity'] <= part['min_order_level']:
                            st.warning(
                                f"âš ï¸ Low stock alert: Only {part['quantity']} units remaining!"
                            )

                        st.json({
                            "Name": part['name'],
                            "Part Number": part['part_number'],
                            "Current Quantity": int(part['quantity']),
                            "Min Order Level": int(part['min_order_level'])
                        })

                        # Quick actions for scanned part
                        action = st.selectbox("Select Action",
                                              ["Check In", "Check Out"],
                                              key="barcode_action")

                        quantity = st.number_input(
                            "Quantity",
                            min_value=1,
                            max_value=int(part['quantity'])
                            if action == "Check Out" else None,
                            value=1,
                            key="barcode_quantity")

                        if st.button(f"Confirm {action}"):
                            transaction_type = 'check_in' if action == "Check In" else 'check_out'

                            success, error_msg = st.session_state.data_manager.record_transaction(
                                part['id'], transaction_type, quantity)

                            if success:
                                st.success(
                                    f"Successfully {action.lower()}ed {quantity} units"
                                )

                                # Check if action triggered low stock alert
                                updated_df = st.session_state.data_manager.get_part_by_id(
                                    part['id'])
                                if updated_df is not None and not updated_df.empty:
                                    updated_part = updated_df.iloc[0]
                                    if updated_part[
                                            'quantity'] <= updated_part[
                                                'min_order_level']:
                                        st.warning(
                                            f"âš ï¸ Stock Alert: {updated_part['name']} is now below minimum stock level!"
                                        )

                                st.session_state.last_scans.append(
                                    f"{datetime.now().strftime('%H:%M:%S')} - {part['name']}"
                                )
                                st.rerun()
                            else:
                                st.error(f"Transaction failed: {error_msg}")
                    else:
                        st.error("Barcode not found in system")
                else:
                    st.error(
                        "Invalid barcode format. Expected format: SP followed by 8 digits"
                    )

        with col2:
            st.markdown("### Last Scanned")
            for scan in st.session_state.last_scans[-5:]:
                st.text(scan)

    with tab2:
        df = st.session_state.data_manager.get_all_parts()

        if not df.empty:
            selected_part = st.selectbox("Select Part",
                                         df['name'].tolist(),
                                         key="checkin_part")

            part_data = df[df['name'] == selected_part].iloc[0]

            # Show stock level warning if applicable
            if part_data['quantity'] <= part_data['min_order_level']:
                st.warning(
                    f"âš ï¸ Low stock alert: Only {part_data['quantity']} units remaining!"
                )
            else:
                st.info(f"Current quantity: {part_data['quantity']}")

            col1, col2 = st.columns(2)

            with col1:
                with st.form("check_in_form"):
                    check_in_quantity = st.number_input("Check-In Quantity",
                                                        min_value=1,
                                                        value=1,
                                                        key="checkin_quantity")

                    if st.form_submit_button("Check-In"):
                        success, error_msg = st.session_state.data_manager.record_transaction(
                            part_data['id'], 'check_in', check_in_quantity)
                        if success:
                            st.success(f"Checked in {check_in_quantity} units")
                            st.rerun()
                        else:
                            st.error(f"Transaction failed: {error_msg}")

            with col2:
                with st.form("check_out_form"):
                    check_out_quantity = st.number_input(
                        "Check-Out Quantity",
                        min_value=1,
                        max_value=int(part_data['quantity']),
                        value=1,
                        key="checkout_quantity")

                    if st.form_submit_button("Check-Out"):
                        success, error_msg = st.session_state.data_manager.record_transaction(
                            part_data['id'], 'check_out', check_out_quantity)

                        if success:
                            # Check if this transaction triggered a low stock alert
                            updated_df = st.session_state.data_manager.get_part_by_id(
                                part_data['id'])
                            if updated_df is not None and not updated_df.empty:
                                updated_part = updated_df.iloc[0]
                                if updated_part['quantity'] <= updated_part[
                                        'min_order_level']:
                                    st.warning(
                                        f"âš ï¸ Stock Alert: {updated_part['name']} is now below minimum stock level!"
                                    )

                            #st.rerun()
                            st.success(f"Checked out {check_out_quantity} units")
                             # Debugging: Check if success message is reached
                            st.write("Check-Out successful")
                            #st.rerun()
                        else:
                            st.error(f"Transaction failed: {error_msg}")

                            

    with tab3:
        low_stock = st.session_state.data_manager.get_low_stock_items()

        if not low_stock.empty:
            st.warning("The following items are below minimum order level:")

            for _, part in low_stock.iterrows():
                st.markdown(f"""
                    **{part['name']}** (Part #: {part['part_number']})
                    - Current Quantity: {part['quantity']}
                    - Minimum Order Level: {part['min_order_level']}
                    - Suggested Order Quantity: {part['min_order_quantity']}
                """)
        else:
            st.success("All items are above minimum order level")


if __name__ == "__main__":
    render_operations_page()




================================================================
End of Codebase
================================================================
