This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/devcontainer.json
.replit
.repomix/bundles.json
.streamlit/config.toml
app_settings.py
barcode_handler.py
data_manager.py
docs/SHIP INVENTORY MANAGEMENT SYSTEM.docx
generated-icon.png
inventory.db
logo.png
main.py
MDL_logo.png
navbar.py
pages/admin.py
pages/analytics.py
pages/data_management.py
pages/departments.py
pages/inventory.py
pages/operations.py
pages/reports.py
pyproject.toml
README.md
repl_nix_workspace.egg-info/dependency_links.txt
repl_nix_workspace.egg-info/PKG-INFO
repl_nix_workspace.egg-info/requires.txt
repl_nix_workspace.egg-info/SOURCES.txt
repl_nix_workspace.egg-info/top_level.txt
replit.nix
requirements.txt
session_manager.py
user_management.py
utils.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="session_manager.py">
import streamlit as st
import streamlit.components.v1 as components
import uuid
from datetime import datetime, timedelta
import sqlite3
import json

class SessionManager:
    def __init__(self):
        self.cookie_name = "inventory_session"
    
    def set_session_cookie(self, user_data):
        """Set session cookie with user data"""
        session_id = str(uuid.uuid4())
        expires = datetime.now() + timedelta(hours=24)
        
        cookie_script = f"""
        <script>
        function setCookie(name, value, days) {{
            var expires = "";
            if (days) {{
                var date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }}
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Strict";
        }}
        
        var userData = {json.dumps(user_data)};
        userData.session_id = "{session_id}";
        userData.expires = "{expires.isoformat()}";
        
        setCookie("{self.cookie_name}", JSON.stringify(userData), 1);
        </script>
        """
        
        components.html(cookie_script, height=0)
        return session_id
    
    def get_session_cookie(self):
        """Get session data from cookie"""
        cookie_script = f"""
        <script>
        function getCookie(name) {{
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {{
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
            }}
            return null;
        }}
        
        var sessionData = getCookie("{self.cookie_name}");
        if (sessionData) {{
            window.parent.postMessage({{type: 'sessionData', data: sessionData}}, '*');
        }} else {{
            window.parent.postMessage({{type: 'sessionData', data: null}}, '*');
        }}
        </script>
        """
        
        # Create a placeholder for the cookie data
        if 'cookie_data' not in st.session_state:
            st.session_state.cookie_data = None
        
        # Use Streamlit's components to communicate with frontend
        components.html(cookie_script, height=0)
        
        # Check for message from frontend
        if 'cookie_data' in st.session_state and st.session_state.cookie_data:
            try:
                return json.loads(st.session_state.cookie_data)
            except:
                pass
        return None
    
    def clear_session_cookie(self):
        """Clear session cookie"""
        clear_script = f"""
        <script>
        function deleteCookie(name) {{
            document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
        }}
        deleteCookie("{self.cookie_name}");
        </script>
        """
        
        components.html(clear_script, height=0)
    
    def verify_session(self, session_data):
        """Verify if session data is valid"""
        if not session_data:
            return False
        
        # Check expiration
        expires_str = session_data.get('expires')
        if expires_str:
            try:
                expires = datetime.fromisoformat(expires_str)
                if datetime.now() > expires:
                    return False
            except:
                return False
        
        # Verify user exists and is active
        username = session_data.get('username')
        if not username:
            return False
        
        try:
            conn = sqlite3.connect('inventory.db')
            cursor = conn.cursor()
            cursor.execute(
                "SELECT isactive FROM users WHERE username = ?", 
                (username,)
            )
            result = cursor.fetchone()
            conn.close()
            
            return result and result[0] == 1
        except:
            return False

# Global session manager instance
session_manager = SessionManager()
</file>

<file path=".devcontainer/devcontainer.json">
{
  "name": "Python 3",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/python:1-3.11-bullseye",
  "customizations": {
    "codespaces": {
      "openFiles": [
        "README.md",
        "main.py"
      ]
    },
    "vscode": {
      "settings": {},
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance"
      ]
    }
  },
  "updateContentCommand": "[ -f packages.txt ] && sudo apt update && sudo apt upgrade -y && sudo xargs apt install -y <packages.txt; [ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user streamlit; echo '‚úÖ Packages installed and Requirements met'",
  "postAttachCommand": {
    "server": "streamlit run main.py --server.enableCORS false --server.enableXsrfProtection false"
  },
  "portsAttributes": {
    "8501": {
      "label": "Application",
      "onAutoForward": "openPreview"
    }
  },
  "forwardPorts": [
    8501
  ]
}
</file>

<file path=".repomix/bundles.json">
{
  "bundles": {}
}
</file>

<file path="pages/data_management.py">
import streamlit as st
import pandas as pd
import sqlite3
from datetime import datetime, timedelta
import random
from user_management import login_required, init_session_state
import navbar
from app_settings import set_page_configuration

set_page_configuration()

current_page = "Data Management"
st.header(current_page)

# Initialize session state
init_session_state()

navbar.nav(current_page)

@login_required
def render_data_management_page():
    # Restrict access to Super User only
    if st.session_state.user_role != 'Super User':
        st.error("üîí Access Denied: This page is only available for Super Users")
        return

    #st.title("Data Management - Super User Only")
    st.warning("üö® **Warning**: These operations will permanently delete and reset all data!")

    tab1, tab2, tab3 = st.tabs(["Reset Database", "Sample Data Setup", "Database Status"])

    with tab1:
        st.subheader("Reset Database Tables")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üóëÔ∏è Reset Departments", type="secondary"):
                if reset_table("departments"):
                    st.success("Departments table reset successfully!")
        
        with col2:
            if st.button("üóëÔ∏è Reset Spare Parts", type="secondary"):
                if reset_table("spare_parts"):
                    st.success("Spare parts table reset successfully!")
        
        with col3:
            if st.button("üóëÔ∏è Reset Transactions", type="secondary"):
                if reset_table("transactions"):
                    st.success("Transactions table reset successfully!")

        st.markdown("---")
        
        if st.button("üí• Reset ALL Tables", type="primary"):
            if st.checkbox("I understand this will delete ALL data permanently"):
                if reset_all_tables():
                    st.success("All tables reset successfully!")
                    st.rerun()

    with tab2:
        st.subheader("Generate Sample Data")
        
        if st.button("üèóÔ∏è Create Sample Departments", type="primary"):
            if create_sample_departments():
                st.success("Sample departments created successfully!")
                st.rerun()
        
        if st.button("üì¶ Create Sample Spare Parts", type="primary"):
            if create_sample_spare_parts():
                st.success("Sample spare parts created successfully!")
                st.rerun()
        
        if st.button("üìä Create Sample Transactions", type="primary"):
            if create_sample_transactions():
                st.success("Sample transactions created successfully!")
                st.rerun()

        st.markdown("---")
        
        if st.button("üöÄ Generate Complete Sample Dataset", type="secondary"):
            if generate_complete_sample_data():
                st.success("Complete sample dataset created successfully!")
                st.rerun()

    with tab3:
        st.subheader("Database Status")
        display_database_status()

def reset_table(table_name):
    """Reset a specific table and its primary key sequence"""
    try:
        conn = sqlite3.connect('inventory.db')
        cursor = conn.cursor()
        
        # Delete all data from table
        cursor.execute(f"DELETE FROM {table_name}")
        
        # Reset SQLite sequence for primary key only if the table uses AUTOINCREMENT
        # Check if the table exists in sqlite_sequence
        #cursor.execute("SELECT name FROM sqlite_sequence WHERE name=?", (table_name,))
        #table_in_sequence = cursor.fetchone()
        
        #if table_in_sequence:
        #    cursor.execute(f"DELETE FROM sqlite_sequence WHERE name='{table_name}'")
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Error resetting {table_name}: {str(e)}")
        return False

def reset_all_tables():
    """Reset all three main tables"""
    try:
        tables = ["transactions", "spare_parts", "departments"]
        for table in tables:
            if not reset_table(table):
                return False
        return True
    except Exception as e:
        st.error(f"Error resetting all tables: {str(e)}")
        return False

def create_sample_departments():
    """Create hierarchical department structure"""
    try:
        conn = sqlite3.connect('inventory.db')
        cursor = conn.cursor()

        # First, check if departments already exist to avoid duplicates
        cursor.execute("SELECT COUNT(*) FROM departments")
        existing_count = cursor.fetchone()[0]
        
        if existing_count > 0:
            st.warning(f"Departments table already contains {existing_count} records. Skipping creation.")
            conn.close()
            return True

        # Parent departments (Main areas of the ship)
        parent_departments = [
            ("ENG", "Engineering"),
            ("DECK", "Deck Operations"),
            ("NAV", "Navigation"),
            ("CAB", "Cabins & Accommodation"),
            ("GAL", "Galley & Provisions")
        ]

        # Child departments for each parent
        child_departments = {
            "ENG": [
                ("MEP", "Main Engine Parts"),
                ("AEP", "Auxiliary Engine Parts"),
                ("ELC", "Electrical Systems"),
                ("HUL", "Hull Maintenance")
            ],
            "DECK": [
                ("CAR", "Cargo Operations"),
                ("ANC", "Anchoring Systems"),
                ("MOR", "Mooring Equipment"),
                ("LIF", "Life Saving Appliances")
            ],
            "NAV": [
                ("COM", "Communication Systems"),
                ("RAD", "Radar & Navigation"),
                ("AIS", "AIS & GPS Systems")
            ],
            "CAB": [
                ("PLU", "Plumbing Systems"),
                ("HVAC", "HVAC Systems"),
                ("FIR", "Fire Fighting Equipment")
            ],
            "GAL": [
                ("KIT", "Kitchen Equipment"),
                ("REF", "Refrigeration"),
                ("PRO", "Provisions Storage")
            ]
        }

        # Insert parent departments
        parent_ids = {}
        for code, name in parent_departments:
            cursor.execute(
                "INSERT INTO departments (code, name, parent_id) VALUES (?, ?, ?)",
                (code, name, None)
            )
            parent_ids[code] = cursor.lastrowid

        # Insert child departments
        for parent_code, children in child_departments.items():
            parent_id = parent_ids[parent_code]
            for child_code, child_name in children:
                cursor.execute(
                    "INSERT INTO departments (code, name, parent_id) VALUES (?, ?, ?)",
                    (child_code, child_name, parent_id)
                )

        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Error creating sample departments: {str(e)}")
        return False

def create_sample_spare_parts():
    """Create sample spare parts data"""
    try:
        conn = sqlite3.connect('inventory.db')
        cursor = conn.cursor()

        # Check if spare parts already exist
        cursor.execute("SELECT COUNT(*) FROM spare_parts")
        existing_count = cursor.fetchone()[0]
        
        if existing_count > 0:
            st.warning(f"Spare parts table already contains {existing_count} records. Skipping creation.")
            conn.close()
            return True

        # Get all child departments
        cursor.execute("SELECT id, code, name FROM departments WHERE parent_id IS NOT NULL")
        child_depts = cursor.fetchall()

        if not child_depts:
            st.error("No child departments found. Please create departments first.")
            return False

        # Sample spare parts data
        spare_part_categories = {
            "MEP": [
                ("Piston Ring Set", "High-pressure piston rings for main engine", "MEP-PRS-001"),
                ("Cylinder Liner", "Main engine cylinder liner assembly", "MEP-CL-002"),
                ("Fuel Injector", "Electronic fuel injector unit", "MEP-FI-003"),
                ("Turbocharger Blade", "Turbine blades for turbocharger", "MEP-TCB-004"),
                ("Bearing Set", "Main bearing set for crankshaft", "MEP-BS-005")
            ],
            "AEP": [
                ("Generator Brush", "Carbon brushes for auxiliary generator", "AEP-GB-001"),
                ("Cooling Pump Impeller", "Impeller for cooling water pump", "AEP-CPI-002"),
                ("Air Compressor Valve", "Reed valves for air compressor", "AEP-ACV-003"),
                ("Heat Exchanger Tube", "Copper tubes for heat exchanger", "AEP-HET-004")
            ],
            "ELC": [
                ("Circuit Breaker", "Main circuit breaker 400A", "ELC-CB-001"),
                ("Motor Starter", "Electric motor starter unit", "ELC-MS-002"),
                ("Control Relay", "24V DC control relay", "ELC-CR-003"),
                ("Cable Terminal", "High voltage cable terminals", "ELC-CT-004")
            ],
            "CAR": [
                ("Crane Wire Rope", "20mm wire rope for deck crane", "CAR-CWR-001"),
                ("Container Lock", "Twist locks for containers", "CAR-CL-002"),
                ("Hatch Cover Seal", "Rubber seals for hatch covers", "CAR-HCS-003")
            ],
            "COM": [
                ("VHF Radio Unit", "Marine VHF communication radio", "COM-VHF-001"),
                ("Satellite Phone", "Satellite communication phone", "COM-SAT-002"),
                ("Antenna Cable", "Coaxial cable for antennas", "COM-AC-003")
            ]
        }

        part_id = 1
        for dept_id, dept_code, dept_name in child_depts:
            # Get parts for this department category or use default
            parts = spare_part_categories.get(dept_code, [
                (f"General Part {i}", f"General spare part for {dept_name}", f"{dept_code}-GP-{i:03d}")
                for i in range(1, 6)
            ])

            for i, (name, description, part_number) in enumerate(parts):
                # Create variations for each base part
                for variant in range(4):  # 4 variants per base part
                    variant_part_number = f"{part_number}-V{variant+1:02d}"
                    variant_name = f"{name} - Variant {variant+1}"
                    
                    # Create stock levels: some normal, some low stock, some last piece
                    if variant == 0:  # Last piece level
                        quantity = 1
                        min_order_level = 5
                    elif variant == 1:  # Low stock
                        quantity = random.randint(2, 4)
                        min_order_level = 10
                    else:  # Normal stock
                        quantity = random.randint(15, 50)
                        min_order_level = 10
                    
                    min_order_quantity = random.randint(5, 20)
                    
                    cursor.execute('''
                        INSERT INTO spare_parts (
                            part_number, name, description, quantity, line_no, page_no,
                            order_no, material_code, ilms_code, item_denomination,
                            mustered, department_id, compartment_no, box_no, remark,
                            min_order_level, min_order_quantity, barcode, last_updated, status
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        variant_part_number,
                        variant_name,
                        f"{description} - Specific variant for specialized use",
                        quantity,
                        random.randint(1, 10),
                        f"P{random.randint(1, 5)}",
                        f"ORD-{random.randint(1000, 9999)}",
                        f"MAT-{random.randint(100, 999)}",
                        f"ILMS-{random.randint(1000, 9999)}",
                        "Pieces",
                        random.choice([True, False]),
                        dept_id,
                        f"C{random.randint(1, 10)}",
                        f"B{random.randint(1, 20)}",
                        "Sample data for testing",
                        min_order_level,
                        min_order_quantity,
                        f"{dept_code}-{variant_part_number}",
                        datetime.now(),
                        random.choice(["In Store", "Operational", "Under Maintenance"])
                    ))
                    
                    part_id += 1

        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Error creating sample spare parts: {str(e)}")
        return False

def create_sample_transactions():
    """Create sample transaction data for the last 3 months"""
    try:
        conn = sqlite3.connect('inventory.db')
        cursor = conn.cursor()

        # Check if transactions already exist
        cursor.execute("SELECT COUNT(*) FROM transactions")
        existing_count = cursor.fetchone()[0]
        
        if existing_count > 0:
            st.warning(f"Transactions table already contains {existing_count} records. Skipping creation.")
            conn.close()
            return True

        # Get all spare parts
        cursor.execute("SELECT id, quantity, min_order_level FROM spare_parts")
        spare_parts = cursor.fetchall()

        if not spare_parts:
            st.error("No spare parts found. Please create spare parts first.")
            return False

        # Generate transactions for the last 90 days
        end_date = datetime.now()
        start_date = end_date - timedelta(days=90)

        transaction_reasons = {
            'check_out': ['Operational Use', 'Maintenance', 'Replacement', 'Emergency'],
            'check_in': ['Restock', 'Return from Maintenance', 'New Supply']
        }

        for part_id, current_quantity, min_order_level in spare_parts:
            # Generate transaction pattern for this part
            transactions_count = random.randint(5, 20)
            
            for _ in range(transactions_count):
                # Random date within the last 90 days
                days_ago = random.randint(0, 90)
                transaction_date = end_date - timedelta(days=days_ago)
                
                # Decide transaction type with bias towards check_out for realism
                transaction_type = random.choices(
                    ['check_out', 'check_in'], 
                    weights=[70, 30]
                )[0]
                
                if transaction_type == 'check_out':
                    quantity = random.randint(1, min(5, current_quantity))
                    reason = random.choice(transaction_reasons['check_out'])
                    remarks = f"Used for {reason.lower()}"
                else:
                    quantity = random.randint(1, 10)
                    reason = random.choice(transaction_reasons['check_in'])
                    remarks = f"Received from {reason.lower()}"
                
                cursor.execute('''
                    INSERT INTO transactions (part_id, transaction_type, quantity, timestamp, reason, remarks)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (part_id, transaction_type, quantity, transaction_date, reason, remarks))

        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Error creating sample transactions: {str(e)}")
        return False

def generate_complete_sample_data():
    """Generate complete sample dataset in correct order"""
    try:
        st.info("Starting sample data generation...")
        
        if not create_sample_departments():
            return False
        st.success("‚úì Departments created")
        
        if not create_sample_spare_parts():
            return False
        st.success("‚úì Spare parts created")
        
        if not create_sample_transactions():
            return False
        st.success("‚úì Transactions created")
        
        return True
    except Exception as e:
        st.error(f"Error generating complete sample data: {str(e)}")
        return False

def display_database_status():
    """Display current database statistics"""
    try:
        conn = sqlite3.connect('inventory.db')
        
        # Get table counts
        tables = ['departments', 'spare_parts', 'transactions', 'users']
        stats = {}
        
        for table in tables:
            try:
                count = pd.read_sql_query(f"SELECT COUNT(*) as count FROM {table}", conn).iloc[0]['count']
                stats[table] = count
            except:
                stats[table] = 0  # Table might not exist
        
        # Display statistics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Departments", stats['departments'])
        with col2:
            st.metric("Spare Parts", stats['spare_parts'])
        with col3:
            st.metric("Transactions", stats['transactions'])
        with col4:
            st.metric("Users", stats['users'])
        
        # Show low stock alerts
        st.subheader("Current Stock Alerts")
        
        try:
            low_stock = pd.read_sql_query('''
                SELECT name, quantity, min_order_level, min_order_quantity 
                FROM spare_parts 
                WHERE quantity <= min_order_level AND quantity > 1
                ORDER BY quantity ASC
            ''', conn)
            
            last_piece = pd.read_sql_query('''
                SELECT name, quantity, min_order_level, min_order_quantity 
                FROM spare_parts 
                WHERE quantity = 1
                ORDER BY name
            ''', conn)
            
            if not low_stock.empty:
                st.warning(f"üö® {len(low_stock)} Low Stock Items")
                st.dataframe(low_stock, hide_index=True)
            
            if not last_piece.empty:
                st.error(f"üî• {len(last_piece)} Last Piece Level Items")
                st.dataframe(last_piece, hide_index=True)
                
        except Exception as e:
            st.info("No stock alert data available yet")
        
        conn.close()
        
    except Exception as e:
        st.error(f"Error displaying database status: {str(e)}")

if __name__ == "__main__":
    render_data_management_page()
</file>

<file path="README.md">
# Ship Spare Parts Inventory Management System

A barcode-based inventory tracking system for ship spare parts management with hierarchical department structure, role-based access control, and advanced reporting capabilities.

## Features

- üö¢ **Barcode Management**: Generate and scan barcodes with ABC-D-1234 format
- üèóÔ∏è **Hierarchical Departments**: Parent-child department structure with inheritance
- üîê **Role-Based Access**: Three user levels (Super User, Admin, User)
- üìä **Advanced Analytics**: Stock levels, transaction trends, demand forecasting
- üì¶ **Bulk Operations**: CSV import/export for inventory management
- üö® **Alerts**: Low stock and last piece level notifications
- üì± **Mobile-Friendly**: Responsive web interface

## Installation

### Prerequisites
- Python 3.11+
- pip package manager

### Setup
1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ship-inventory-system.git
   cd ship-inventory-system
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

3. Run the application:
   ```bash
   streamlit run main.py
   ```

4. Access the app at `http://localhost:8501`

## Configuration

Edit `.streamlit/config.toml` for UI customization:
```toml
[theme]
primaryColor = "#0066cc"
backgroundColor = "#ffffff"
secondaryBackgroundColor = "#f0f2f6"
textColor = "#262730"
```

## Usage

### Default Credentials
- **Admin**: `admin` / `admin123`
- **Roles**:
  - Super User: Full system access
  - Admin: Limited admin privileges
  - User: Department-specific access

### Key Modules
1. **Inventory Management** (`pages/inventory.py`)
   - Add/edit spare parts
   - Bulk import via CSV
   - Department-wise views

2. **Operations** (`pages/operations.py`)
   - Barcode scanning interface
   - Check-in/check-out functionality

3. **Reports** (`pages/reports.py`)
   - Stock level analysis
   - Transaction history
   - Data export

4. **User Management** (`pages/admin.py`)
   - User creation/modification
   - Role assignment

## Database Schema
The SQLite database (`inventory.db`) contains four main tables:
1. `departments` - Hierarchical department structure
2. `spare_parts` - Inventory items with barcodes
3. `transactions` - Check-in/check-out records
4. `users` - Authentication and access control

## Deployment Options

### 1. Local Development
```bash
streamlit run main.py
```

### 2. Docker Container
```bash
docker build -t ship-inventory .
docker run -p 8501:8501 ship-inventory
```

### 3. Streamlit Sharing
1. Create `requirements.txt` from `pyproject.toml`
2. Deploy to Streamlit Community Cloud

## Screenshots

| Module | Preview |
|--------|---------|
| Login | ![Login Screen](screenshots/login.png) |
| Dashboard | ![Dashboard](screenshots/dashboard.png) |
| Barcode Scanning | ![Barcode](screenshots/barcode.png) |

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/your-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin feature/your-feature`)
5. Open a Pull Request

## License

MIT License - See [LICENSE](LICENSE) for details.

## Support

For issues or feature requests, please [open an issue](https://github.com/yourusername/ship-inventory-system/issues).

---

**Note**: Replace placeholder images and GitHub URLs with your actual project resources before publishing.
</file>

<file path="repl_nix_workspace.egg-info/dependency_links.txt">

</file>

<file path="repl_nix_workspace.egg-info/PKG-INFO">
Metadata-Version: 2.4
Name: repl-nix-workspace
Version: 0.1.0
Summary: Add your description here
Requires-Python: >=3.11
Requires-Dist: barcode>=1.0.4
Requires-Dist: numpy>=2.2.3
Requires-Dist: pandas>=2.2.3
Requires-Dist: pillow>=11.1.0
Requires-Dist: plotly>=6.0.0
Requires-Dist: python-barcode>=0.15.1
Requires-Dist: streamlit-option-menu>=0.4.0
Requires-Dist: streamlit>=1.43.1
Requires-Dist: trafilatura>=2.0.0
</file>

<file path="repl_nix_workspace.egg-info/requires.txt">
barcode>=1.0.4
numpy>=2.2.3
pandas>=2.2.3
pillow>=11.1.0
plotly>=6.0.0
python-barcode>=0.15.1
streamlit-option-menu>=0.4.0
streamlit>=1.43.1
trafilatura>=2.0.0
</file>

<file path="repl_nix_workspace.egg-info/SOURCES.txt">
pyproject.toml
pages/admin.py
pages/analytics.py
pages/inventory.py
pages/operations.py
pages/reports.py
repl_nix_workspace.egg-info/PKG-INFO
repl_nix_workspace.egg-info/SOURCES.txt
repl_nix_workspace.egg-info/dependency_links.txt
repl_nix_workspace.egg-info/requires.txt
repl_nix_workspace.egg-info/top_level.txt
</file>

<file path="repl_nix_workspace.egg-info/top_level.txt">
pages
</file>

<file path="replit.nix">
{pkgs}: {
  deps = [
    pkgs.glibcLocales
    pkgs.zlib
    pkgs.tk
    pkgs.tcl
    pkgs.openjpeg
    pkgs.libxcrypt
    pkgs.libwebp
    pkgs.libtiff
    pkgs.libjpeg
    pkgs.libimagequant
    pkgs.lcms2
    pkgs.freetype
  ];
}
</file>

<file path="requirements.txt">
barcode>=1.0.4
numpy>=2.2.3
pandas>=2.2.3
Pillow>=11.1.0
plotly>=6.0.0
python-barcode>=0.15.1
streamlit-option-menu>=0.4.0
streamlit>=1.43.1
trafilatura>=2.0.0
sqlite3>=3.35.0
</file>

<file path=".replit">
modules = ["python-3.11"]

[nix]
channel = "stable-24_05"

[deployment]
deploymentTarget = "autoscale"
run = ["sh", "-c", "streamlit run main.py"]

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Streamlit App"

[[workflows.workflow]]
name = "Streamlit App"
author = "agent"

[workflows.workflow.metadata]
agentRequireRestartOnSave = false

[[workflows.workflow.tasks]]
task = "packager.installForAll"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "streamlit run main.py"
waitForPort = 5000

[[ports]]
localPort = 5000
externalPort = 80

[[ports]]
localPort = 8501
externalPort = 3000
</file>

<file path="app_settings.py">
import streamlit as st
from PIL import Image
import base64
from io import BytesIO

def set_page_configuration():
    """Set page configuration with session persistence settings"""
    st.set_page_config(
        page_title="Ship Inventory Management System",
        page_icon="üö¢",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    # Apply custom CSS for better session persistence
    st.markdown("""
    <style>
        /* Your existing CSS styles */
        .stAppHeader {
            background-color: rgba(255, 255, 255, 0.0);
            visibility: visible;
        }

        /* Remove blank space at top and bottom */
        .block-container {
            padding-top: 0rem;
            padding-bottom: 0rem;
        }
        
        /* Remove blank space at the center canvas */
        .st-emotion-cache-z5fcl4 {
            position: relative;
            top: -62px;
        }
        
        /* Make the toolbar transparent and the content below it clickable */
        .st-emotion-cache-18ni7ap {
            pointer-events: none;
            background: rgb(255 255 255 / 0%)
        }
        .st-emotion-cache-zq5wmm {
            pointer-events: auto;
            background: rgb(255 255 255);
            border-radius: 5px;
        }
        
        /* Improve session persistence visual feedback */
        .session-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
    """, unsafe_allow_html=True)

def add_logo_background(logo_path="logo.png", opacity=0.4):
    """Add a visible but non-intrusive logo background"""
    try:
        # Open and prepare logo
        logo = Image.open(logo_path)
        
        # Convert to base64
        buffered = BytesIO()
        logo.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode()
        
        # CSS with guaranteed visibility
        css = f"""
        <style>
        [data-testid="stAppViewContainer"] > .main {{
            background-image: url("data:image/png;base64,{img_str}");
            background-size: 40%;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-opacity: 0.4;
            position: relative;
        }}
        
        [data-testid="stAppViewContainer"] > .main::before {{
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.82);
            z-index: 0;
        }}
        
        [data-testid="stAppViewContainer"] > .main > div {{
            position: relative;
            z-index: 1;
        }}
        </style>
        """
        
        st.markdown(css, unsafe_allow_html=True)
        st.markdown('<div class="main">', unsafe_allow_html=True)
        
    except Exception as e:
        st.error(f"Couldn't load background image: {e}")
</file>

<file path="utils.py">
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from datetime import datetime, timedelta

def create_stock_level_chart(df):
    fig = px.bar(
        df,
        x='name',
        y=['quantity', 'min_order_level'],
        title='Stock Levels vs Minimum Order Levels',
        barmode='group'
    )
    return fig

def create_transaction_trend(df):
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    daily_transactions = df.groupby(['timestamp', 'transaction_type']).size().reset_index(name='count')

    fig = px.line(
        daily_transactions,
        x='timestamp',
        y='count',
        color='transaction_type',
        title='Transaction Trends'
    )
    return fig

def format_transaction_table(df):
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df = df.sort_values('timestamp', ascending=False)
    return df[['timestamp', 'name', 'part_number', 'transaction_type', 'quantity']]

def calculate_moving_average(data, window=7):
    """Calculate moving average for demand forecasting"""
    return data.rolling(window=window).mean()

def calculate_exponential_smoothing(data, alpha=0.3):
    """Calculate exponential smoothing for trend analysis"""
    return data.ewm(alpha=alpha, adjust=False).mean()

def calculate_reorder_point(df, part_id, lead_time_days=7):
    """Calculate reorder point based on average daily demand and lead time"""
    part_transactions = df[df['part_id'] == part_id]
    if part_transactions.empty:
        return 0

    # Calculate daily demand
    daily_demand = part_transactions.groupby('timestamp')['quantity'].sum()
    avg_daily_demand = abs(daily_demand.mean())

    # Add safety stock (20% of lead time demand)
    safety_stock = avg_daily_demand * lead_time_days * 0.2
    reorder_point = (avg_daily_demand * lead_time_days) + safety_stock

    return round(reorder_point)

def calculate_stock_turnover(df, current_stock):
    """Calculate stock turnover rate"""
    if df.empty or current_stock == 0:
        return 0

    total_usage = abs(df[df['transaction_type'] == 'check_out']['quantity'].sum())
    avg_inventory = current_stock / 2  # Simple average inventory calculation

    if avg_inventory == 0:
        return 0

    turnover_rate = total_usage / avg_inventory
    return round(turnover_rate, 2)

def create_demand_forecast_chart(df, part_id, days_to_forecast=30):
    """Create demand forecast visualization"""
    part_transactions = df[df['part_id'] == part_id]
    if part_transactions.empty:
        return None

    # Prepare daily demand data
    daily_demand = part_transactions.groupby('timestamp')['quantity'].sum()

    # Calculate moving average and exponential smoothing
    ma = calculate_moving_average(daily_demand)
    ema = calculate_exponential_smoothing(daily_demand)

    # Create forecast dates
    last_date = daily_demand.index.max()
    forecast_dates = pd.date_range(
        start=last_date, 
        periods=days_to_forecast + 1, 
        freq='D'
    )[1:]

    # Create forecast values using the last 7 days trend
    last_week_trend = ema[-7:].mean()
    forecast_values = [last_week_trend] * days_to_forecast

    # Create visualization
    fig = go.Figure()

    # Historical data
    fig.add_trace(go.Scatter(
        x=daily_demand.index,
        y=daily_demand.values,
        name='Actual Demand',
        mode='lines+markers'
    ))

    # Moving average
    fig.add_trace(go.Scatter(
        x=ma.index,
        y=ma.values,
        name='7-Day Moving Average',
        line=dict(dash='dash')
    ))

    # Exponential moving average
    fig.add_trace(go.Scatter(
        x=ema.index,
        y=ema.values,
        name='Exponential Moving Average',
        line=dict(dash='dot')
    ))

    # Forecast
    fig.add_trace(go.Scatter(
        x=forecast_dates,
        y=forecast_values,
        name='Forecast',
        line=dict(dash='dashdot')
    ))

    fig.update_layout(
        title='Demand Forecast Analysis',
        xaxis_title='Date',
        yaxis_title='Quantity',
        showlegend=True
    )

    return fig
</file>

<file path="pages/departments.py">
import streamlit as st
import pandas as pd
import sqlite3
from user_management import login_required, init_session_state
import navbar
from app_settings import set_page_configuration
from data_manager import DataManager
import time

set_page_configuration()

current_page = "Departments"
st.header(current_page)

# Initialize session state
init_session_state()

navbar.nav(current_page)
    

@login_required
def render_departments_page():

    tab1, tab2 = st.tabs(["Department Grid", "Add Department"])

    with tab1:
        #st.subheader("Department Data Grid")
        
        # Get data as DataFrame
        df = st.session_state.data_manager.get_all_departments_as_df()
        
        if not df.empty:
            # Display as interactive grid
            st.dataframe(
                df,
                column_config={
                    "id": "ID",
                    "code": "Code",
                    "name": "Department Name",
                    "parent_name": "Parent Department"
                },
                hide_index=True,
                use_container_width=True
            )
            
            # Add edit/delete functionality
            st.subheader("Edit Department")
            dept_id = st.selectbox(
                "Select Department to Edit",
                df['id'],
                format_func=lambda x: f"{df[df['id']==x]['code'].iloc[0]} - {df[df['id']==x]['name'].iloc[0]}"
            )
            
            if dept_id:
                dept_data = df[df['id'] == dept_id].iloc[0]
                with st.form(f"edit_form_{dept_id}"):
                    new_code = st.text_input("Code", value=dept_data['code'])
                    new_name = st.text_input("Name", value=dept_data['name'])
                    
                    parent_options = st.session_state.data_manager.get_parent_options()
                    current_parent = None if dept_data['parent_name'] == 'Top Level' else \
                        next((p[0] for p in parent_options if p[1] == dept_data['parent_name']), None)
                    
                    parent_id = st.selectbox(
                        "Parent Department",
                        [None] + [p[0] for p in parent_options],
                        format_func=lambda x: "Top Level" if x is None else \
                            next((p[1] for p in parent_options if p[0] == x), "None"),
                        index=0 if current_parent is None else \
                            [p[0] for p in parent_options].index(current_parent) + 1
                    )
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        if st.form_submit_button("Update"):
                            # Implement update logic
                            if st.session_state.data_manager.update_department(dept_id, new_code, new_name, parent_id):
                                st.rerun()
                                st.toast("Department Updated successfully", icon="‚úÖ")
                                time.sleep(3)  # This will block the UI       
                            else:
                                st.error("Department code already exists")
                    with col2:
                        if st.form_submit_button("Delete"):
                            # Implement delete logic
                            success, message = st.session_state.data_manager.delete_department(dept_id)
                            if success:
                                st.rerun()
                                st.toast("Department deleted successfully!", icon="‚úÖ")
                                time.sleep(3)  # This will block the UI       
                            else:
                                st.error(f"Deletion failed: {message}")
        else:
            st.info("No departments found")

    with tab2:
        #st.subheader("Add New Department")
        with st.form("add_department_form"):
            code = st.text_input("Department Code", max_chars=10)
            name = st.text_input("Department Name")
            
            parent_options = st.session_state.data_manager.get_parent_options()
            is_parent = st.checkbox("This is a top-level department", value=True)
            
            parent_id = None
            if not is_parent and parent_options:
                parent_id = st.selectbox(
                    "Select Parent Department*",
                    [p[0] for p in parent_options],
                    index=None,
                    placeholder="Select Parent Department",
                    format_func=lambda x: next((p[1] for p in parent_options if p[0] == x), None),
                    key = "ListParentDept"
                )
            
            if st.form_submit_button("Add Department"):
                if not is_parent and code and name and parent_id:
                    if st.session_state.data_manager.add_department(code, name, parent_id):
                        st.toast("Department added successfully", icon="‚úÖ")
                        time.sleep(3)  # This will block the UI
                        st.rerun()
                    else:
                        st.error("Department code already exists")
                elif is_parent and code and name:
                    if st.session_state.data_manager.add_department(code, name, parent_id):
                        st.toast("Department added successfully", icon="‚úÖ")
                        time.sleep(3)  # This will block the UI
                        st.rerun()
                    else:
                        st.error("Department code already exists")
                else:
                    st.error("Please fill in all required fields")

if __name__ == "__main__":
    render_departments_page()
</file>

<file path="pyproject.toml">
[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "barcode>=1.0.4",
    "numpy>=2.2.3",
    "pandas>=2.2.3",
    "pillow>=11.1.0",
    "plotly>=6.0.0",
    "python-barcode>=0.15.1",
    "streamlit-option-menu>=0.4.0",
    "streamlit>=1.43.1",
    "trafilatura>=2.0.0",
]
</file>

<file path="barcode_handler.py">
import barcode
from barcode.writer import ImageWriter
import io
import base64
import re
from barcode import *

class BarcodeHandler:
    @staticmethod
    def generate_barcode(value):
        # Generate Code128 barcode
        barcode_class = barcode.get_barcode_class('code128')
        rv = io.BytesIO()
        barcode_class(value, writer=ImageWriter()).write(rv)
        return base64.b64encode(rv.getvalue()).decode()

    @staticmethod
    def generate_unique_barcode(prefix="SP"):
        import random
        import string

        # Generate a random 8-character string
        random_part = ''.join(random.choices(string.digits, k=8))
        return f"{prefix}{random_part}"

    @staticmethod
    def validate_barcode(barcode):
        """
        Validate barcode format: 3 chars - 1 char - 4 digits (ABC-D-1234)
        
        Args:
            barcode (str): The barcode to validate
            
        Returns:
            tuple: (is_valid: bool, error_message: str)
        """
        if not isinstance(barcode, str):
            return False, "Barcode must be a string"
        
        pattern = r'^[A-Za-z]{3}-[A-Za-z]{1}-\d{4}$'
        print("barcode:", barcode)  # Add this temporarily
        if not re.fullmatch(pattern, barcode):
            return False, (
                "Invalid barcode format. "
                "Required format: ABC-D-1234 (3 letters, 1 letter, 4 digits)"
            )
        
        return True, "Barcode is valid"

    @staticmethod
    def get_part_by_barcode(data_manager, barcode_input):
        """Look up a part using its barcode"""
        try:
            df = data_manager.get_all_parts()
            part = df[df['barcode'] == barcode_input]
            if not part.empty:
                return True, part.iloc[0]
            return False, None
        except Exception as e:
            print(f"Error looking up barcode: {e}")
            return False, None
</file>

<file path="user_management.py">
import sqlite3
import hashlib
import pandas as pd
import secrets
from datetime import datetime
import streamlit as st
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from session_manager import session_manager

class UserManager:

    def __init__(self, db_path='inventory.db'):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.create_users_table()

    def get_all_users_with_departments(self):
        query = '''
            SELECT u.id, u.username, u.role, 
                   u.created_at, u.last_login, u.isactive,
                   d1.name as parent_department,
                   d2.name as child_department
            FROM users u
            LEFT JOIN departments d2 ON u.department_id = d2.id
            LEFT JOIN departments d1 ON d2.parent_id = d1.id
            ORDER BY u.role, u.username
        '''
        return pd.read_sql_query(query, self.conn)
    
    def get_parent_departments(self):
        query = "SELECT id, name FROM departments WHERE parent_id IS NULL"
        return pd.read_sql_query(query, self.conn)
    
    def get_child_departments(self, parent_id):
        if not parent_id:
            return pd.DataFrame(columns=['id', 'name'])
        query = "SELECT id, name FROM departments WHERE parent_id = ?"
        return pd.read_sql_query(query, self.conn, params=(parent_id,))
    
    def update_user(self, user_id, username, role, department_id=None, new_password=None):
        cursor = self.conn.cursor()
        try:
            if new_password:
                # Update password if provided
                password_hash, salt = self.hash_password(new_password)
                cursor.execute(
                    '''
                    UPDATE users 
                    SET username=?, role=?, department_id=?, 
                        password_hash=?, salt=?
                    WHERE id=?
                ''', (username, role, department_id, password_hash, salt, user_id))
            else:
                # Update without changing password
                #print("dept_id:", department_id)  # Add this temporarily
                cursor.execute('''
                    UPDATE users 
                    SET username=?, role=?, department_id=?
                    WHERE id=?
                ''', (username, role, department_id, user_id))
                
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)
    
    def deactivate_user(self, user_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE users SET isactive=0 WHERE id=?", (user_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)
    
    def activate_user(self, user_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute("UPDATE users SET isactive=1 WHERE id=?", (user_id,))
            self.conn.commit()
            return True, None
        except sqlite3.Error as e:
            return False, str(e)

    def create_users_table(self):
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    salt TEXT NOT NULL,
                    role TEXT NOT NULL,
                    created_at TIMESTAMP,
                    last_login TIMESTAMP,
                    isactive boolean NOT NULL default 0
                )
            ''')
            self.conn.commit()
            # Create default admin user if not exists
            self.create_default_admin()
        except sqlite3.Error as e:
            print(f"Error creating users table: {e}")
            raise

    def create_default_admin(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM users WHERE username = 'admin'")
        if cursor.fetchone()[0] == 0:
            self.register_user('admin', 'admin123', 'admin')

    def hash_password(self, password, salt=None):
        if salt is None:
            salt = secrets.token_hex(16)
        password_hash = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'),
                                            salt.encode('utf-8'),
                                            100000).hex()
        return password_hash, salt

    def register_user(self, username, password, role='staff', department_id=None, isactive=True):
        cursor = self.conn.cursor()
        try:
            password_hash, salt = self.hash_password(password)
            cursor.execute(
                '''
                INSERT INTO users (username, password_hash, salt, role, created_at, department_id, isactive)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (username, password_hash, salt, role, datetime.now(), department_id, isactive))
            self.conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False

    def verify_user(self, username, password):
        cursor = self.conn.cursor()
        cursor.execute(
            '''
            SELECT password_hash, salt, role, isactive, id, department_id FROM users WHERE username = ?
        ''', (username, ))
        result = cursor.fetchone()

        if result:
            stored_hash, salt, role, isactive, user_id, department_id = result
            password_hash, _ = self.hash_password(password, salt)
            if password_hash == stored_hash:
                if not isactive:
                    return False, None, None, None, "Account is inactive. Please contact administrator."
                # Update last login time
                cursor.execute(
                    '''
                    UPDATE users SET last_login = ? WHERE username = ?
                ''', (datetime.now(), username))
                self.conn.commit()
                return True, role, user_id, department_id, None
        return False, None, None, None, "Invalid username or password"

    def get_all_users(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT id, username, role, created_at, last_login 
            FROM users
        ''')
        return cursor.fetchall()

    def update_user_role(self, username, new_role):
        cursor = self.conn.cursor()
        try:
            cursor.execute(
                '''
                UPDATE users SET role = ? WHERE username = ?
            ''', (new_role, username))
            self.conn.commit()
            return True
        except sqlite3.Error:
            return False


def init_session_state():
    """Initialize all required session state variables with persistence"""
    # Enable experimental session state persistence
    if 'persistent_initialized' not in st.session_state:
        st.session_state.persistent_initialized = True
    
    required_vars = {
        'authenticated': False,
        'username': None,
        'user_role': None,
        'user_id': None,
        'user_department_id': None,
        'login_time': None,
        'session_id': None
    }
    
    for var, default in required_vars.items():
        if var not in st.session_state:
            st.session_state[var] = default
    
    # Initialize managers (these will be recreated if needed)
    if 'user_manager' not in st.session_state:
        st.session_state.user_manager = UserManager()
    
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    
    if 'barcode_handler' not in st.session_state:
        st.session_state.barcode_handler = BarcodeHandler()
    
    # Check for existing session in browser storage
    check_persistent_session()

def check_persistent_session():
    """Check if there's a persistent session that can be restored"""
    try:
        # Try to get session from browser storage
        if st.experimental_user and hasattr(st.experimental_user, 'get'):
            saved_session = st.experimental_user.get('inventory_session')
            if saved_session:
                # Verify the session is still valid
                if verify_session(saved_session):
                    restore_session(saved_session)
    except:
        pass  # Browser storage not available

def verify_session(session_data):
    """Verify if a saved session is still valid"""
    try:
        if not session_data:
            return False
        
        # Check if session has expired (24 hours)
        login_time = session_data.get('login_time')
        if login_time:
            login_dt = datetime.fromisoformat(login_time)
            if (datetime.now() - login_dt).total_seconds() > 24 * 3600:  # 24 hours
                return False
        
        # Verify user still exists and is active
        user_manager = UserManager()
        username = session_data.get('username')
        
        # Check if user exists and is active
        conn = sqlite3.connect('inventory.db')
        cursor = conn.cursor()
        cursor.execute(
            "SELECT isactive FROM users WHERE username = ?", 
            (username,)
        )
        result = cursor.fetchone()
        conn.close()
        
        if result and result[0] == 1:  # User is active
            return True
        
        return False
    except:
        return False

def restore_session(session_data):
    """Restore session from saved data"""
    try:
        st.session_state.authenticated = True
        st.session_state.username = session_data.get('username')
        st.session_state.user_role = session_data.get('user_role')
        st.session_state.user_id = session_data.get('user_id')
        st.session_state.user_department_id = session_data.get('user_department_id')
        st.session_state.login_time = session_data.get('login_time')
        st.session_state.session_id = session_data.get('session_id')
    except:
        pass

def save_session_to_storage():
    """Save current session to browser storage"""
    try:
        if st.experimental_user and hasattr(st.experimental_user, 'set'):
            session_data = {
                'username': st.session_state.username,
                'user_role': st.session_state.user_role,
                'user_id': st.session_state.user_id,
                'user_department_id': st.session_state.user_department_id,
                'login_time': st.session_state.login_time.isoformat() if st.session_state.login_time else None,
                'session_id': st.session_state.session_id
            }
            st.experimental_user.set('inventory_session', session_data)
    except:
        pass  # Browser storage not available

def clear_session_storage():
    """Clear session from browser storage"""
    try:
        if st.experimental_user and hasattr(st.experimental_user, 'set'):
            st.experimental_user.set('inventory_session', None)
    except:
        pass

def login_required(func):
    """Decorator to require login for accessing pages"""
    def wrapper(*args, **kwargs):
        init_session_state()
        
        # Check if user is authenticated
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            render_login_page()
            st.stop()
        
        return func(*args, **kwargs)
    return wrapper

def render_login_page():
    """Render login page with session persistence"""
    st.image("logo.png", width=100)
    st.write("")
    st.title("Ship Inventory Management System")

    # Initialize session state
    init_session_state()

    with st.form("login_form", clear_on_submit=False):
        username = st.text_input("Username", key="login_username")
        password = st.text_input("Password", type="password", key="login_password")

        if st.form_submit_button("Login", use_container_width=True):
            if username and password:
                success, role, user_id, user_department_id, error_msg = st.session_state.user_manager.verify_user(
                    username, password)
                if success:
                    # Set session state variables
                    st.session_state.authenticated = True
                    st.session_state.username = username
                    st.session_state.user_role = role
                    st.session_state.user_id = user_id
                    st.session_state.user_department_id = user_department_id
                    st.session_state.login_time = datetime.now()
                    st.session_state.session_id = secrets.token_hex(16)
                    
                    # Save session to cookie
                    user_data = {
                        'username': username,
                        'user_role': role,
                        'user_id': user_id,
                        'user_department_id': user_department_id,
                        'login_time': st.session_state.login_time.isoformat()
                    }
                    session_manager.set_session_cookie(user_data)
                    
                    st.success(f"Welcome back, {username}!")
                    st.rerun()
                else:
                    st.error(error_msg or "Invalid username or password")
            else:
                st.error("Please enter both username and password")

# Add a function to check and maintain session
def check_session():
    """Check and maintain user session"""
    init_session_state()
    
    # If user was previously authenticated but session state was lost,
    # try to restore from cookies or other persistence methods
    if st.session_state.authenticated:
        return True
    
    return False
</file>

<file path="pages/admin.py">
import streamlit as st
import pandas as pd
from user_management import login_required, init_session_state
import navbar
from app_settings import set_page_configuration
from datetime import datetime

set_page_configuration()

current_page = "User Management"
st.header(current_page)

# Initialize session state
init_session_state()

navbar.nav(current_page)

@login_required
def render_admin_page():
    if st.session_state.user_role in ['Admin', 'User']:
        st.error("You don't have permission to access this page")
        return
    
    tab1, tab2 = st.tabs(["Manage Users", "Add New User"])

    with tab1:
        #st.subheader("User Management")
        
        df = st.session_state.user_manager.get_all_users_with_departments()
        
        if not df.empty:
            # Display non-editable grid with status indicator
            st.dataframe(
                df[['id', 'username', 'role', 'isactive', 'parent_department', 'child_department']],
                column_config={
                    "id": "ID",
                    "username": "Username",
                    "role": "Role",
                    "isactive": st.column_config.CheckboxColumn(
                        "Active",
                        disabled=True,
                        help="User account status"
                    ),
                    "parent_department": "Parent Department",
                    "child_department": "Child Department"
                },
                hide_index=True,
                use_container_width=True
            )
            
            # Edit user section
            st.subheader("Edit User")
            user_id = st.selectbox(
                "Select User to Edit",
                df['id'],
                format_func=lambda x: f"{df[df['id']==x]['username'].iloc[0]} ({df[df['id']==x]['role'].iloc[0]})"
            )
            
            if user_id:
                user_data = df[df['id'] == user_id].iloc[0]

                # Initialize department variables
                department_id = None
                current_parent = None
                current_child = None

                # Department selection (outside the form for proper cascading)
                if user_data['role'] == "User":
                    st.subheader("Department Assignment")
                    parent_depts = st.session_state.user_manager.get_parent_departments()
                    
                    # Safely get current parent department
                    if not pd.isna(user_data['parent_department']) and not parent_depts.empty:
                        parent_match = parent_depts[parent_depts['name'] == user_data['parent_department']]
                        current_parent = parent_match['id'].iloc[0] if not parent_match.empty else None
                    
                    # Parent department selection
                    selected_parent = st.selectbox(
                        "Parent Department",
                        parent_depts['id'].tolist(),
                        format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                        index=parent_depts['id'].tolist().index(current_parent) if current_parent is not None else 0,
                        key=f"parent_dept_{user_id}"
                    )
                    
                    # Child departments (will update when parent changes)
                    child_depts = st.session_state.user_manager.get_child_departments(selected_parent)
                    
                    # Safely get current child department
                    if not pd.isna(user_data['child_department']) and not child_depts.empty:
                        child_match = child_depts[child_depts['name'] == user_data['child_department']]
                        current_child = child_match['id'].iloc[0] if not child_match.empty else None
                    
                    if not child_depts.empty:
                        # Safely determine index
                        child_index = 0
                        if current_child is not None and current_child in child_depts['id'].tolist():
                            child_index = child_depts['id'].tolist().index(current_child)
                        
                        department_id = st.selectbox(
                            "Child Department",
                            child_depts['id'].tolist(),
                            format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                            index=child_index,
                            key=f"child_dept_{user_id}"
                        )
                    else:
                        st.warning("No child departments available")
                        department_id = None

                with st.form(f"edit_form_{user_id}"):
                    st.markdown("**Basic Information**")
                    new_username = st.text_input("Username", value=user_data['username'])
                    st.text_input("Role", value=user_data['role'], disabled=True)
                    new_role = user_data['role']  # Keep original role
                    
                    # Password change section
                    st.markdown("**Password Change**")
                    change_password = st.checkbox("Change password")
                    new_password = None
                    if change_password:
                        new_password = st.text_input("New Password", type="password")
                        confirm_password = st.text_input("Confirm Password", type="password")
                        if new_password and new_password != confirm_password:
                            st.error("Passwords do not match!")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        if st.form_submit_button("Update"):
                            # Validate password change if requested
                            #print("department_id:", department_id)  # Add this temporarily
                            if change_password and not new_password:
                                st.error("Please enter a new password")
                            else:
                                # Update user information
                                success, message = st.session_state.user_manager.update_user(
                                    user_id=user_id,
                                    username=new_username,
                                    role=new_role,
                                    department_id=department_id if new_role == "User" else None,
                                    new_password=new_password if change_password else None
                                )
                                if success:
                                    st.toast("User updated successfully!", icon="‚úÖ")
                                    st.success("User updated successfully!")
                                    st.rerun()
                                else:
                                    st.error(f"Update failed: {message}")
                    with col2:
                        if st.form_submit_button("Deactivate" if user_data['isactive'] else "Activate"):
                            if user_id == st.session_state.get('user_id'):
                                st.error("You cannot deactivate your own account!")
                            else:
                                if user_data['isactive']:
                                    success, message = st.session_state.user_manager.deactivate_user(user_id)
                                else:
                                    success, message = st.session_state.user_manager.activate_user(user_id)
                                
                                if success:
                                    st.success("User status updated successfully!")
                                    st.toast("User status updated successfully!", icon="‚úÖ")
                                    st.rerun()
                                else:
                                    st.error(f"Operation failed: {message}")
        else:
            st.info("No users found")

    with tab2:
        st.subheader("Add New User")
        
        # Initialize form fields in session state
        if 'new_username' not in st.session_state:
            st.session_state.new_username = ""
        if 'new_password' not in st.session_state:
            st.session_state.new_password = ""
        if 'new_user_role' not in st.session_state:
            st.session_state.new_user_role = "User"
        if 'new_user_parent_dept' not in st.session_state:
            st.session_state.new_user_parent_dept = None
        if 'new_user_child_dept' not in st.session_state:
            st.session_state.new_user_child_dept = None
        if 'show_success' not in st.session_state:
            st.session_state.show_success = False
        
        # Show success toast if flag is set
        if st.session_state.show_success:
            st.toast("User added successfully!", icon="‚úÖ")
            st.session_state.show_success = False  # Reset the flag
        
        # Department selection
        role = st.selectbox(
            "Role*", 
            ["Super User", "Admin", "User"], 
            key="new_user_role_select",
            index=["Super User", "Admin", "User"].index(st.session_state.new_user_role)
        )
        
        if role == "User":
            st.markdown("**Department Assignment**")
            parent_depts = st.session_state.user_manager.get_parent_departments()
            selected_parent = st.selectbox(
                "Parent Department*",
                parent_depts['id'].tolist(),
                index=None,
                placeholder="Select Parent Department",
                format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                key="new_user_parent_dept_select"
            )
                
            if selected_parent:
                child_depts = st.session_state.user_manager.get_child_departments(selected_parent)
                if not child_depts.empty:
                    department_id = st.selectbox(
                        "Child Department*",
                        child_depts['id'].tolist(),
                        index=None,
                        placeholder="Select Child Department",
                        format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                        key="new_user_child_dept_select"
                    )
                else:
                    st.warning("No child departments available")
                    department_id = None

        with st.form("add_user_form"):
            new_username = st.text_input("Username*", value=st.session_state.new_username, key="new_username_input")
            new_password = st.text_input("Password*", type="password", value=st.session_state.new_password, key="new_password_input")
            
            submit_button = st.form_submit_button(label='Submit')

            if submit_button:
                if not new_username or not new_password:
                    st.error("Please fill in all required fields (marked with *)")
                elif role == "User" and not department_id:
                    st.error("Please select a child department for user")
                else:
                    if st.session_state.user_manager.register_user(
                            username=new_username,
                            password=new_password,
                            role=role,
                            department_id=department_id if role == "User" else None, isactive=True):
                        
                        # Set success flag and clear form
                        st.session_state.show_success = True
                        st.session_state.new_username = ""
                        st.session_state.new_password = ""
                        st.session_state.new_user_role = "User"
                        st.session_state.new_user_parent_dept = None
                        st.session_state.new_user_child_dept = None
                        
                        # Rerun to show toast and clear form
                        st.rerun()
                    else:
                        st.error("Username already exists")
                        st.toast("Username already exists!", icon="‚úÖ")

if __name__ == "__main__":
    render_admin_page()
</file>

<file path=".streamlit/config.toml">
[server]
headless = true
address = "0.0.0.0"
port = 8501
#port = 8501 for hosting on streamlit community cloud
#port = 5000 for local development

[theme]
primaryColor = "#0066cc"
backgroundColor = "#ffffff"
secondaryBackgroundColor = "#f0f2f6"
textColor = "#262730"

[ui]
hideTopBar = true

[client]
showSidebarNavigation = false
toolbarMode = "minimal"
</file>

<file path="pages/reports.py">
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import numpy as np
from user_management import login_required, init_session_state
import navbar
from app_settings import set_page_configuration
from data_manager import DataManager
import io
import base64

set_page_configuration()

current_page = "Reports"
st.header(current_page)

current_page = "User Management"
st.header(current_page)

navbar.nav(current_page)

@login_required
def render_reports_page():
    #st.title("üìã Advanced Reporting Dashboard")
    
    # Initialize session state
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    
    # Get current user's department and role
    current_user_role = st.session_state.get('user_role')
    current_user_dept_id = st.session_state.get('user_department_id')
    
    # Display user context
    if current_user_role == 'User':
        dept_info = st.session_state.data_manager.get_department_info(current_user_dept_id)
        if dept_info is not None and not dept_info.empty:
            st.info(f"üîê **Department Access**: {dept_info['child_department']} - {dept_info['parent_department']}")
    
    # Date range selector
    col1, col2 = st.columns([1, 1])
    with col1:
        report_period = st.selectbox(
            "Report Period",
            ["Last 7 Days", "Last 30 Days", "Last 90 Days", "Last 6 Months", "Last Year", "Custom Range"],
            index=1
        )
    
    # Department selector for Admin/Super User
    selected_child_dept = None
    if current_user_role in ['Admin', 'Super User']:
        with col2:
            parent_depts = st.session_state.data_manager.get_parent_departments()
            if not parent_depts.empty:
                selected_parent = st.selectbox(
                    "Parent Department",
                    parent_depts['id'].tolist(),
                    index=0,
                    format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                    key="report_parent_dept"
                )
                
                child_depts = st.session_state.data_manager.get_child_departments(selected_parent)
                if not child_depts.empty:
                    selected_child_dept = st.selectbox(
                        "Child Department",
                        child_depts['id'].tolist(),
                        index=0,
                        format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                        key="report_child_dept"
                    )
    else:
        # Regular users can only see their assigned department
        selected_child_dept = current_user_dept_id
    
    # Calculate date range
    days = get_days_from_period(report_period)
    
    # Main reports navigation
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üìä Executive Summary", 
        "üì¶ Inventory Reports", 
        "üîÑ Transaction Reports", 
        "üö® Alert Reports",
        "üìà Performance Reports"
    ])

    with tab1:
        render_executive_summary(days, selected_child_dept, current_user_role)
    
    with tab2:
        render_inventory_reports(days, selected_child_dept, current_user_role)
    
    with tab3:
        render_transaction_reports(days, selected_child_dept, current_user_role)
    
    with tab4:
        render_alert_reports(days, selected_child_dept, current_user_role)
    
    with tab5:
        render_performance_reports(days, selected_child_dept, current_user_role)

def ensure_numeric_dataframe(df, numeric_columns=None):
    """Ensure specified columns are numeric, handling conversion errors"""
    if df.empty:
        return df
    
    df = df.copy()
    
    if numeric_columns is None:
        numeric_columns = ['quantity', 'min_order_level', 'min_order_quantity', 'line_no']
    
    for col in numeric_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
    
    return df

def render_executive_summary(days, department_id, user_role):
    """Executive summary with key metrics and overview"""
    st.subheader("üèÜ Executive Summary")
    
    # Get data based on user role and department
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    # Ensure numeric data types
    spare_parts = ensure_numeric_dataframe(spare_parts)
    transactions = ensure_numeric_dataframe(transactions)
    
    if spare_parts.empty:
        st.warning("No inventory data available for the selected department/period")
        return
    
    # Key Performance Indicators
    st.write("### Key Performance Indicators")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_items = len(spare_parts)
        st.metric("Total Items", total_items)
    
    with col2:
        total_value = calculate_inventory_value(spare_parts)
        st.metric("Inventory Value", f"${total_value:,.0f}")
    
    with col3:
        turnover_rate = calculate_turnover_rate(transactions, spare_parts)
        st.metric("Turnover Rate", f"{turnover_rate:.1f}x")
    
    with col4:
        service_level = calculate_service_level(transactions)
        st.metric("Service Level", f"{service_level:.1f}%")
    
    # Charts Row
    chart_col1, chart_col2 = st.columns(2)
    
    with chart_col1:
        fig = create_inventory_health_chart(spare_parts)
        st.plotly_chart(fig, use_container_width=True)
    
    with chart_col2:
        fig = create_department_activity_chart(transactions, spare_parts)
        st.plotly_chart(fig, use_container_width=True)
    
    # Quick Insights
    st.write("### üìà Quick Insights")
    
    insights_col1, insights_col2 = st.columns(2)
    
    with insights_col1:
        st.info("**Top Moving Items**")
        top_movers = get_top_moving_items(transactions, 5)
        for item in top_movers:
            st.write(f"‚Ä¢ {item['name']}: {item['quantity']} units")
    
    with insights_col2:
        st.warning("**Attention Required**")
        critical_items = get_critical_items(spare_parts, 3)
        for item in critical_items:
            st.write(f"‚Ä¢ {item['name']}: {item['quantity']} left (min: {item['min_level']})")
    
    # Export Executive Summary
    st.download_button(
        "üì• Download Executive Summary",
        generate_executive_summary_pdf(spare_parts, transactions),
        file_name=f"executive_summary_{datetime.now().strftime('%Y%m%d')}.pdf",
        mime="application/pdf"
    )

def render_inventory_reports(days, department_id, user_role):
    """Comprehensive inventory reports"""
    st.subheader("üì¶ Inventory Analysis Reports")
    
    # Get inventory data based on access
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
    
    if spare_parts.empty:
        st.warning("No inventory data available")
        return
    
    # Inventory Report Types
    report_type = st.radio(
        "Select Inventory Report",
        ["Stock Level Analysis", "ABC Classification", "Value Analysis", "Department Summary", "Custom Inventory Report"],
        horizontal=True
    )
    
    if report_type == "Stock Level Analysis":
        render_stock_level_report(spare_parts)
    elif report_type == "ABC Classification":
        render_abc_classification_report(spare_parts)
    elif report_type == "Value Analysis":
        render_value_analysis_report(spare_parts)
    elif report_type == "Department Summary":
        render_department_summary_report(spare_parts, user_role, department_id)
    elif report_type == "Custom Inventory Report":
        render_custom_inventory_report(spare_parts)

def render_transaction_reports(days, department_id, user_role):
    """Transaction history and analysis reports"""
    st.subheader("üîÑ Transaction Analysis Reports")
    
    # Get transaction data based on access
    if user_role == 'User':
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    if transactions.empty:
        st.warning("No transaction data available for the selected period")
        return
    
    # Transaction Report Types
    report_type = st.radio(
        "Select Transaction Report",
        ["Transaction History", "Movement Analysis", "Trend Analysis", "User Activity", "Custom Transaction Report"],
        horizontal=True
    )
    
    if report_type == "Transaction History":
        render_transaction_history_report(transactions)
    elif report_type == "Movement Analysis":
        render_movement_analysis_report(transactions)
    elif report_type == "Trend Analysis":
        render_trend_analysis_report(transactions, days)
    elif report_type == "User Activity":
        st.info("User activity tracking requires additional user session data")
    elif report_type == "Custom Transaction Report":
        render_custom_transaction_report(transactions)

def render_alert_reports(days, department_id, user_role):
    """Alert and exception reports"""
    st.subheader("üö® Alert & Exception Reports")
    
    # Get data based on access
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        low_stock = st.session_state.data_manager.get_low_stock_items_by_dept(department_id)
        last_piece = st.session_state.data_manager.get_last_piece_stock_items_by_dept(department_id)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            low_stock = st.session_state.data_manager.get_low_stock_items_by_dept(department_id)
            last_piece = st.session_state.data_manager.get_last_piece_stock_items_by_dept(department_id)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            low_stock = st.session_state.data_manager.get_low_stock_items()
            last_piece = st.session_state.data_manager.get_last_piece_stock_items()
    
    # Ensure data consistency
    spare_parts = ensure_data_consistency(spare_parts)
    low_stock = ensure_data_consistency(low_stock)
    last_piece = ensure_data_consistency(last_piece)
    
    # Alert Summary
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("Last Piece Alerts", len(last_piece), delta=len(last_piece), delta_color="inverse")
    
    with col2:
        st.metric("Low Stock Alerts", len(low_stock), delta=len(low_stock), delta_color="inverse")
    
    with col3:
        out_of_stock = len(spare_parts[spare_parts['quantity'] == 0])
        st.metric("Out of Stock", out_of_stock, delta=out_of_stock, delta_color="inverse")
    
    # Alert Details
    alert_tab1, alert_tab2, alert_tab3 = st.tabs(["Last Piece Alerts", "Low Stock Alerts", "Reordering Recommendations"])
    
    with alert_tab1:
        if not last_piece.empty:
            # Fix: Handle missing child_department column
            display_columns = ['name', 'part_number', 'quantity', 'min_order_level', 'min_order_quantity']
            
            # Add child_department if it exists, otherwise try to get department info
            if 'child_department' in last_piece.columns:
                display_columns.append('child_department')
            elif 'department_id' in last_piece.columns:
                # Create department mapping
                dept_mapping = {}
                for dept_id in last_piece['department_id'].unique():
                    dept_info = st.session_state.data_manager.get_department_info(dept_id)
                    if dept_info is not None and not dept_info.empty:
                        dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                    else:
                        dept_mapping[dept_id] = f'Dept_{dept_id}'
                last_piece['child_department'] = last_piece['department_id'].map(dept_mapping)
                display_columns.append('child_department')
            
            # Only include columns that actually exist
            available_columns = [col for col in display_columns if col in last_piece.columns]
            
            st.dataframe(
                last_piece[available_columns],
                use_container_width=True
            )
            
            # Generate reorder list
            st.download_button(
                "üìã Generate Reorder List",
                generate_reorder_list(last_piece),
                file_name="immediate_reorder_list.csv",
                mime="text/csv"
            )
        else:
            st.success("‚úÖ No last piece level alerts")
    
    with alert_tab2:
        if not low_stock.empty:
            # Fix: Handle missing child_department column for low stock
            display_columns = ['name', 'part_number', 'quantity', 'min_order_level', 'min_order_quantity']
            
            # Add child_department if it exists, otherwise try to get department info
            if 'child_department' in low_stock.columns:
                display_columns.append('child_department')
            elif 'department_id' in low_stock.columns:
                # Create department mapping
                dept_mapping = {}
                for dept_id in low_stock['department_id'].unique():
                    dept_info = st.session_state.data_manager.get_department_info(dept_id)
                    if dept_info is not None and not dept_info.empty:
                        dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                    else:
                        dept_mapping[dept_id] = f'Dept_{dept_id}'
                low_stock['child_department'] = low_stock['department_id'].map(dept_mapping)
                display_columns.append('child_department')
            
            # Only include columns that actually exist
            available_columns = [col for col in display_columns if col in low_stock.columns]
            
            st.dataframe(
                low_stock[available_columns],
                use_container_width=True
            )
        else:
            st.success("‚úÖ No low stock alerts")
    
    with alert_tab3:
        render_reordering_recommendations(spare_parts)

def ensure_data_consistency(df, expected_columns=None):
    """Ensure dataframe has expected columns and proper data types"""
    if df.empty:
        return df
    
    df = df.copy()
    
    # Ensure numeric columns are properly typed
    numeric_columns = ['quantity', 'min_order_level', 'min_order_quantity', 'line_no']
    for col in numeric_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
    
    # Handle department information
    if 'child_department' not in df.columns and 'department_id' in df.columns:
        # Create department mapping
        dept_mapping = {}
        for dept_id in df['department_id'].unique():
            dept_info = st.session_state.data_manager.get_department_info(dept_id)
            if dept_info is not None and not dept_info.empty:
                dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
            else:
                dept_mapping[dept_id] = f'Dept_{dept_id}'
        df['child_department'] = df['department_id'].map(dept_mapping)
    elif 'child_department' not in df.columns:
        df['child_department'] = 'General Department'
    
    # Fill any NaN values in critical columns
    if 'child_department' in df.columns:
        df['child_department'] = df['child_department'].fillna('Unknown Department')
    
    return df

def render_performance_reports(days, department_id, user_role):
    """Performance and analytics reports"""
    st.subheader("üìà Performance & Analytics Reports")
    
    # Get data based on access
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    # Performance Metrics
    perf_col1, perf_col2, perf_col3, perf_col4 = st.columns(4)
    
    with perf_col1:
        stock_accuracy = calculate_stock_accuracy(spare_parts, transactions)
        st.metric("Stock Accuracy", f"{stock_accuracy}%")
    
    with perf_col2:
        fill_rate = calculate_fill_rate(transactions)
        st.metric("Fill Rate", f"{fill_rate}%")
    
    with perf_col3:
        carrying_cost = calculate_carrying_cost(spare_parts)
        st.metric("Carrying Cost", f"${carrying_cost:,.0f}")
    
    with perf_col4:
        optimal_stock = calculate_optimal_stock_percentage(spare_parts)
        st.metric("Optimal Stock", f"{optimal_stock}%")
    
    # Performance Charts
    chart_col1, chart_col2 = st.columns(2)
    
    with chart_col1:
        fig = create_performance_trend_chart(transactions)
        st.plotly_chart(fig, use_container_width=True)
    
    with chart_col2:
        fig = create_efficiency_chart(spare_parts, transactions)
        st.plotly_chart(fig, use_container_width=True)
    
    # Department Comparison (only for Admin/Super User)
    if user_role in ['Admin', 'Super User'] and not department_id:
        st.subheader("Department Performance Comparison")
        fig = create_department_comparison_chart(spare_parts, transactions)
        st.plotly_chart(fig, use_container_width=True)

# =============================================================================
# REPORT RENDERING FUNCTIONS
# =============================================================================

def render_stock_level_report(spare_parts):
    """Render detailed stock level analysis report"""
    st.write("### Stock Level Analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric column
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    
    # Stock level distribution
    fig = px.histogram(
        spare_parts,
        x='quantity',
        nbins=20,
        title="Stock Level Distribution",
        labels={'quantity': 'Quantity in Stock'}
    )
    st.plotly_chart(fig, use_container_width=True)
    
    # Stock level details
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**Stock Level Summary**")
        summary_data = {
            'Metric': ['Average Stock', 'Median Stock', 'Max Stock', 'Min Stock'],
            'Value': [
                spare_parts['quantity'].mean(),
                spare_parts['quantity'].median(),
                spare_parts['quantity'].max(),
                spare_parts['quantity'].min()
            ]
        }
        st.dataframe(pd.DataFrame(summary_data), use_container_width=True)
    
    with col2:
        st.write("**Stock Level Ranges**")
        # Use pandas cut with proper numeric conversion
        ranges = pd.cut(
            spare_parts['quantity'], 
            bins=[0, 1, 5, 10, 20, 50, 100, float('inf')],
            labels=['0', '1-5', '6-10', '11-20', '21-50', '51-100', '100+']
        )
        range_counts = ranges.value_counts().sort_index()
        st.dataframe(range_counts, use_container_width=True)
    
    # Export stock level report
    st.download_button(
        "üì• Download Stock Level Report",
        spare_parts.to_csv(index=False),
        file_name=f"stock_level_report_{datetime.now().strftime('%Y%m%d')}.csv",
        mime="text/csv"
    )

def render_abc_classification_report(spare_parts):
    """Render ABC classification report"""
    st.write("### ABC Inventory Classification")
    
    # Perform ABC analysis
    abc_data = perform_abc_analysis(spare_parts)
    
    if not abc_data.empty:
        # ABC summary
        col1, col2 = st.columns([2, 1])
        
        with col1:
            fig = px.pie(
                abc_data,
                names='abc_class',
                title="ABC Classification Distribution"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.write("**ABC Summary**")
            abc_summary = abc_data.groupby('abc_class').agg({
                'name': 'count',
                'estimated_value': 'sum'
            }).rename(columns={'name': 'item_count', 'estimated_value': 'total_value'})
            abc_summary['value_percentage'] = (abc_summary['total_value'] / abc_summary['total_value'].sum() * 100).round(1)
            st.dataframe(abc_summary, use_container_width=True)
        
        # Detailed ABC data
        st.write("**Classified Items**")
        st.dataframe(
            abc_data[['name', 'part_number', 'quantity', 'estimated_value', 'abc_class']],
            use_container_width=True
        )
        
        # Export ABC report
        st.download_button(
            "üì• Download ABC Classification Report",
            abc_data.to_csv(index=False),
            file_name=f"abc_classification_report_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv"
        )

def render_value_analysis_report(spare_parts):
    """Render inventory value analysis report"""
    st.write("### Inventory Value Analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Calculate estimated values (simplified)
    spare_parts['estimated_value'] = spare_parts['quantity'] * spare_parts['min_order_level'] * 10
    
    # Value distribution
    if 'child_department' in spare_parts.columns and not spare_parts['child_department'].isna().all():
        fig = px.treemap(
            spare_parts,
            path=['child_department', 'name'],
            values='estimated_value',
            title="Inventory Value Distribution by Department"
        )
        st.plotly_chart(fig, use_container_width=True)
    else:
        fig = px.treemap(
            spare_parts,
            path=['name'],
            values='estimated_value',
            title="Inventory Value Distribution"
        )
        st.plotly_chart(fig, use_container_width=True)
    
    # Top valued items
    st.write("**Top 20 Highest Value Items**")
    top_items = spare_parts.nlargest(20, 'estimated_value')[['name', 'part_number', 'quantity', 'estimated_value']]
    if 'child_department' in spare_parts.columns:
        top_items['child_department'] = spare_parts['child_department']
    st.dataframe(top_items, use_container_width=True)
    
    # Value summary by department
    if 'child_department' in spare_parts.columns and not spare_parts['child_department'].isna().all():
        dept_value = spare_parts.groupby('child_department').agg({
            'estimated_value': 'sum',
            'name': 'count'
        }).rename(columns={'name': 'item_count', 'estimated_value': 'total_value'})
        dept_value = dept_value.sort_values('total_value', ascending=False)
        
        st.write("**Value by Department**")
        st.dataframe(dept_value, use_container_width=True)

def render_department_summary_report(spare_parts, user_role, department_id):
    """Render department-specific summary report"""
    st.write("### Department Inventory Summary")
    
    if user_role == 'User' or department_id:
        # Single department view
        dept_info = st.session_state.data_manager.get_department_info(department_id)
        if dept_info is not None and not dept_info.empty:
            st.info(f"**Department**: {dept_info['child_department']} - {dept_info['parent_department']}")
        
        # Department-specific metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total Items", len(spare_parts))
        
        with col2:
            total_value = calculate_inventory_value(spare_parts)
            st.metric("Total Value", f"${total_value:,.0f}")
        
        with col3:
            avg_stock = spare_parts['quantity'].mean()
            st.metric("Average Stock", f"{avg_stock:.1f}")
        
        with col4:
            stock_health = (len(spare_parts[spare_parts['quantity'] > spare_parts['min_order_level']]) / len(spare_parts)) * 100
            st.metric("Stock Health", f"{stock_health:.1f}%")
    else:
        # Multi-department view for Admin/Super User
        if 'child_department' in spare_parts.columns:
            dept_summary = spare_parts.groupby('child_department').agg({
                'name': 'count',
                'quantity': 'sum',
                'min_order_level': 'mean'
            }).rename(columns={'name': 'item_count', 'quantity': 'total_quantity'})
            
            st.dataframe(dept_summary, use_container_width=True)

def render_custom_inventory_report(spare_parts):
    """Render customizable inventory report"""
    st.write("### Custom Inventory Report Builder")
    
    # Column selection
    available_columns = [
        'part_number', 'name', 'description', 'quantity', 'min_order_level',
        'min_order_quantity', 'barcode', 'status', 'child_department', 'compartment_no', 'box_no'
    ]
    
    selected_columns = st.multiselect(
        "Select columns to include",
        available_columns,
        default=['part_number', 'name', 'quantity', 'min_order_level', 'child_department']
    )
    
    # Filters
    st.write("**Apply Filters**")
    filter_col1, filter_col2 = st.columns(2)
    
    with filter_col1:
        min_quantity = st.number_input("Minimum Quantity", min_value=0, value=0)
        max_quantity = st.number_input("Maximum Quantity", min_value=0, value=1000)
    
    with filter_col2:
        status_filter = st.multiselect(
            "Status Filter",
            spare_parts['status'].unique() if 'status' in spare_parts.columns else [],
            default=[]
        )
    
    # Generate custom report
    if st.button("Generate Custom Report"):
        filtered_data = spare_parts.copy()
        
        # Apply quantity filters
        filtered_data = filtered_data[
            (filtered_data['quantity'] >= min_quantity) & 
            (filtered_data['quantity'] <= max_quantity)
        ]
        
        # Apply status filter
        if status_filter and 'status' in filtered_data.columns:
            filtered_data = filtered_data[filtered_data['status'].isin(status_filter)]
        
        # Select columns
        if selected_columns:
            # Ensure columns exist
            existing_columns = [col for col in selected_columns if col in filtered_data.columns]
            filtered_data = filtered_data[existing_columns]
        
        st.write("**Custom Report Results**")
        st.dataframe(filtered_data, use_container_width=True)
        
        # Export custom report
        st.download_button(
            "üì• Download Custom Report",
            filtered_data.to_csv(index=False),
            file_name=f"custom_inventory_report_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv"
        )

def render_transaction_history_report(transactions):
    """Render transaction history report"""
    st.write("### Transaction History Report")
    
    # Date filter
    col1, col2 = st.columns(2)
    with col1:
        start_date = st.date_input("Start Date", value=datetime.now() - timedelta(days=30))
    with col2:
        end_date = st.date_input("End Date", value=datetime.now())
    
    # Filter transactions by date
    transactions['timestamp'] = pd.to_datetime(transactions['timestamp'])
    filtered_transactions = transactions[
        (transactions['timestamp'].dt.date >= start_date) & 
        (transactions['timestamp'].dt.date <= end_date)
    ]
    
    if not filtered_transactions.empty:
        # Transaction summary
        summary_col1, summary_col2, summary_col3 = st.columns(3)
        
        with summary_col1:
            total_transactions = len(filtered_transactions)
            st.metric("Total Transactions", total_transactions)
        
        with summary_col2:
            check_outs = len(filtered_transactions[filtered_transactions['transaction_type'] == 'check_out'])
            st.metric("Check-Outs", check_outs)
        
        with summary_col3:
            check_ins = len(filtered_transactions[filtered_transactions['transaction_type'] == 'check_in'])
            st.metric("Check-Ins", check_ins)
        
        # Detailed transaction data
        st.dataframe(
            filtered_transactions[[
                'timestamp', 'name', 'part_number', 'transaction_type', 
                'quantity', 'reason', 'remarks', 'child_department'
            ]],
            use_container_width=True
        )
        
        # Export transaction history
        st.download_button(
            "üì• Download Transaction History",
            filtered_transactions.to_csv(index=False),
            file_name=f"transaction_history_{start_date}_{end_date}.csv",
            mime="text/csv"
        )
    else:
        st.warning("No transactions found for the selected date range")

def render_movement_analysis_report(transactions):
    """Render item movement analysis report"""
    st.write("### Item Movement Analysis")
    
    # Movement analysis
    movement_data = transactions.groupby(['name', 'transaction_type']).agg({
        'quantity': 'sum',
        'timestamp': 'count'
    }).reset_index()
    
    # Pivot for better visualization
    movement_pivot = movement_data.pivot_table(
        index='name', 
        columns='transaction_type', 
        values='quantity', 
        aggfunc='sum'
    ).fillna(0)
    
    movement_pivot['net_movement'] = movement_pivot.get('check_in', 0) - movement_pivot.get('check_out', 0)
    movement_pivot = movement_pivot.sort_values('net_movement', ascending=False)
    
    st.dataframe(movement_pivot, use_container_width=True)
    
    # Top movers chart
    top_movers = movement_pivot.head(10)
    fig = px.bar(
        top_movers.reset_index(),
        x='name',
        y=['check_in', 'check_out'],
        title="Top 10 Moving Items",
        barmode='group'
    )
    st.plotly_chart(fig, use_container_width=True)

def render_trend_analysis_report(transactions, days):
    """Render transaction trend analysis"""
    st.write("### Transaction Trend Analysis")
    
    # Daily trend
    transactions['date'] = pd.to_datetime(transactions['timestamp']).dt.date
    daily_trend = transactions.groupby(['date', 'transaction_type']).size().reset_index(name='count')
    
    fig = px.line(
        daily_trend,
        x='date',
        y='count',
        color='transaction_type',
        title="Daily Transaction Trends"
    )
    st.plotly_chart(fig, use_container_width=True)
    
    # Weekly pattern
    transactions['day_of_week'] = pd.to_datetime(transactions['timestamp']).dt.day_name()
    weekly_pattern = transactions.groupby(['day_of_week', 'transaction_type']).size().reset_index(name='count')
    
    days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    weekly_pattern['day_of_week'] = pd.Categorical(weekly_pattern['day_of_week'], categories=days_order, ordered=True)
    weekly_pattern = weekly_pattern.sort_values('day_of_week')
    
    fig = px.bar(
        weekly_pattern,
        x='day_of_week',
        y='count',
        color='transaction_type',
        title="Weekly Transaction Pattern",
        barmode='group'
    )
    st.plotly_chart(fig, use_container_width=True)

def render_custom_transaction_report(transactions):
    """Render customizable transaction report"""
    st.write("### Custom Transaction Report Builder")
    
    # Similar to custom inventory report but for transactions
    available_columns = [
        'timestamp', 'name', 'part_number', 'transaction_type', 'quantity',
        'reason', 'remarks', 'child_department', 'parent_department'
    ]
    
    selected_columns = st.multiselect(
        "Select columns to include",
        available_columns,
        default=['timestamp', 'name', 'transaction_type', 'quantity', 'reason']
    )
    
    # Transaction type filter
    transaction_types = st.multiselect(
        "Transaction Types",
        transactions['transaction_type'].unique(),
        default=transactions['transaction_type'].unique()
    )
    
    if st.button("Generate Custom Transaction Report"):
        filtered_data = transactions[transactions['transaction_type'].isin(transaction_types)]
        
        if selected_columns:
            existing_columns = [col for col in selected_columns if col in filtered_data.columns]
            filtered_data = filtered_data[existing_columns]
        
        st.dataframe(filtered_data, use_container_width=True)
        
        st.download_button(
            "üì• Download Custom Transaction Report",
            filtered_data.to_csv(index=False),
            file_name=f"custom_transaction_report_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv"
        )

def render_reordering_recommendations(spare_parts):
    """Render intelligent reordering recommendations"""
    st.write("### üìã Intelligent Reordering Recommendations")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    spare_parts['min_order_quantity'] = pd.to_numeric(spare_parts['min_order_quantity'], errors='coerce').fillna(1)
    
    # Calculate reorder needs
    reorder_needs = spare_parts[
        (spare_parts['quantity'] <= spare_parts['min_order_level']) & 
        (spare_parts['quantity'] > 0)
    ].copy()
    
    if not reorder_needs.empty:
        reorder_needs['reorder_quantity'] = reorder_needs['min_order_quantity']
        
        # Calculate priority using pandas operations
        priority = []
        for _, row in reorder_needs.iterrows():
            if row['quantity'] == 1:
                priority.append('üö® CRITICAL')
            elif row['quantity'] <= row['min_order_level'] * 0.5:
                priority.append('‚ö†Ô∏è HIGH')
            else:
                priority.append('üî∂ MEDIUM')
        
        reorder_needs['priority'] = priority
        
        # Priority summary
        priority_summary = reorder_needs.groupby('priority').agg({
            'name': 'count',
            'reorder_quantity': 'sum'
        }).rename(columns={'name': 'item_count'})
        
        st.write("**Reorder Priority Summary**")
        st.dataframe(priority_summary, use_container_width=True)
        
        # Detailed reorder list
        st.write("**Detailed Reorder List**")
        reorder_display = reorder_needs[[
            'name', 'part_number', 'quantity', 'min_order_level', 
            'reorder_quantity', 'priority', 'child_department'
        ]].sort_values('priority')
        
        st.dataframe(reorder_display, use_container_width=True)
        
        # Generate purchase order
        st.download_button(
            "üõí Generate Purchase Order List",
            reorder_needs[['name', 'part_number', 'reorder_quantity', 'priority']].to_csv(index=False),
            file_name=f"purchase_order_list_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv"
        )
    else:
        st.success("‚úÖ No reordering recommendations at this time")

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def get_days_from_period(period):
    """Convert period selection to days"""
    period_map = {
        "Last 7 Days": 7,
        "Last 30 Days": 30,
        "Last 90 Days": 90,
        "Last 6 Months": 180,
        "Last Year": 365
    }
    return period_map.get(period, 30)

def calculate_inventory_value(spare_parts):
    """Calculate total inventory value (simplified)"""
    if spare_parts.empty:
        return 0
    
    spare_parts = spare_parts.copy()
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    return (spare_parts['quantity'] * spare_parts['min_order_level'] * 10).sum()

def calculate_turnover_rate(transactions, spare_parts):
    """Calculate inventory turnover rate"""
    if transactions.empty or spare_parts.empty:
        return 0
    
    # Ensure numeric data types
    transactions = transactions.copy()
    spare_parts = spare_parts.copy()
    
    transactions['quantity'] = pd.to_numeric(transactions['quantity'], errors='coerce').fillna(0)
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    
    total_usage = abs(transactions[transactions['transaction_type'] == 'check_out']['quantity'].sum())
    avg_inventory = spare_parts['quantity'].mean()
    
    return total_usage / avg_inventory if avg_inventory != 0 else 0

def calculate_service_level(transactions):
    """Calculate service level percentage"""
    if transactions.empty:
        return 100
    total_demand = abs(transactions[transactions['transaction_type'] == 'check_out']['quantity'].sum())
    return 95.0  # Simplified - in real scenario, calculate based on stockouts

def create_inventory_health_chart(spare_parts):
    """Create inventory health status chart"""
    if spare_parts.empty:
        fig = go.Figure()
        fig.add_annotation(text="No data available", x=0.5, y=0.5, showarrow=False)
        return fig
    
    # Ensure we're working with proper data types
    spare_parts = spare_parts.copy()
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Create health status using pandas operations instead of np.select
    health_status = []
    for _, row in spare_parts.iterrows():
        quantity = row['quantity']
        min_order_level = row['min_order_level']
        
        if quantity == 0:
            health_status.append('Out of Stock')
        elif quantity == 1:
            health_status.append('Last Piece')
        elif quantity <= min_order_level:
            health_status.append('Low Stock')
        else:
            health_status.append('Healthy')
    
    spare_parts['health_status'] = health_status
    
    health_counts = spare_parts['health_status'].value_counts()
    
    fig = px.pie(
        values=health_counts.values,
        names=health_counts.index,
        title="Inventory Health Status",
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    
    fig.update_traces(textposition='inside', textinfo='percent+label')
    fig.update_layout(showlegend=False, height=400)
    
    return fig

def create_department_activity_chart(transactions, spare_parts):
    """Create department activity chart"""
    if transactions.empty:
        fig = go.Figure()
        fig.add_annotation(text="No transaction data", x=0.5, y=0.5, showarrow=False)
        return fig
    
    # Merge to get department info
    if 'child_department' not in transactions.columns and 'part_id' in transactions.columns:
        merged = transactions.merge(
            spare_parts[['id', 'child_department']], 
            left_on='part_id', 
            right_on='id'
        )
        dept_activity = merged.groupby('child_department').size()
    else:
        dept_activity = transactions.groupby('child_department').size()
    
    fig = px.bar(
        x=dept_activity.index,
        y=dept_activity.values,
        title="Department Activity Level"
    )
    return fig

def get_top_moving_items(transactions, top_n=5):
    """Get top moving items"""
    if transactions.empty:
        return []
    
    top_movers = transactions.groupby('name')['quantity'].sum().abs().nlargest(top_n)
    return [{'name': name, 'quantity': int(qty)} for name, qty in top_movers.items()]

def get_critical_items(spare_parts, top_n=3):
    """Get most critical items needing attention"""
    if spare_parts.empty:
        return []
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    critical = spare_parts[
        spare_parts['quantity'] <= spare_parts['min_order_level']
    ].nsmallest(top_n, 'quantity')
    
    return [{
        'name': str(row['name']),
        'quantity': int(row['quantity']),
        'min_level': int(row['min_order_level'])
    } for _, row in critical.iterrows()]

def perform_abc_analysis(spare_parts):
    """Perform ABC analysis on inventory"""
    if spare_parts.empty:
        return pd.DataFrame()
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Simplified ABC analysis
    spare_parts['estimated_value'] = spare_parts['quantity'] * spare_parts['min_order_level'] * 10
    spare_parts = spare_parts.sort_values('estimated_value', ascending=False)
    spare_parts['cumulative_percentage'] = spare_parts['estimated_value'].cumsum() / spare_parts['estimated_value'].sum() * 100
    
    # Use pandas operations instead of np.select
    abc_class = []
    for cum_pct in spare_parts['cumulative_percentage']:
        if cum_pct <= 80:
            abc_class.append('A')
        elif cum_pct <= 95:
            abc_class.append('B')
        else:
            abc_class.append('C')
    
    spare_parts['abc_class'] = abc_class
    
    return spare_parts

def calculate_stock_accuracy(spare_parts, transactions):
    """Calculate stock accuracy percentage"""
    return 98.5  # Simplified - in real scenario, compare physical counts

def calculate_fill_rate(transactions):
    """Calculate order fill rate"""
    return 95.2  # Simplified

def calculate_carrying_cost(spare_parts):
    """Calculate inventory carrying cost"""
    total_value = calculate_inventory_value(spare_parts)
    return total_value * 0.25  # 25% carrying cost estimate

def calculate_optimal_stock_percentage(spare_parts):
    """Calculate percentage of items at optimal stock levels"""
    if spare_parts.empty:
        return 0
    optimal = spare_parts[
        (spare_parts['quantity'] > spare_parts['min_order_level']) & 
        (spare_parts['quantity'] <= spare_parts['min_order_level'] * 2)
    ]
    return (len(optimal) / len(spare_parts)) * 100

def create_performance_trend_chart(transactions):
    """Create performance trend chart"""
    fig = go.Figure()
    fig.add_annotation(text="Performance trend analysis", x=0.5, y=0.5, showarrow=False)
    return fig

def create_efficiency_chart(spare_parts, transactions):
    """Create efficiency analysis chart"""
    fig = go.Figure()
    fig.add_annotation(text="Efficiency analysis", x=0.5, y=0.5, showarrow=False)
    return fig

def create_department_comparison_chart(spare_parts, transactions):
    """Create department comparison chart"""
    fig = go.Figure()
    fig.add_annotation(text="Department comparison analysis", x=0.5, y=0.5, showarrow=False)
    return fig

def generate_executive_summary_pdf(spare_parts, transactions):
    """Generate executive summary PDF (placeholder)"""
    return "PDF generation would be implemented here".encode()

def generate_reorder_list(last_piece_items):
    """Generate reorder list CSV"""
    if last_piece_items.empty:
        return "No items to reorder".encode()
    
    # Create a copy to avoid modifying original
    reorder_data = last_piece_items.copy()
    
    # Define base columns
    reorder_columns = ['name', 'part_number', 'quantity', 'min_order_quantity']
    
    # Ensure child_department exists
    if 'child_department' not in reorder_data.columns:
        if 'department_id' in reorder_data.columns:
            # Create department mapping
            dept_mapping = {}
            for dept_id in reorder_data['department_id'].unique():
                dept_info = st.session_state.data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_mapping[dept_id] = f'Dept_{dept_id}'
            reorder_data['child_department'] = reorder_data['department_id'].map(dept_mapping)
        else:
            reorder_data['child_department'] = 'General Department'
    
    # Add child_department to columns if it exists
    if 'child_department' in reorder_data.columns:
        reorder_columns.append('child_department')
    
    # Add reorder quantity
    reorder_data['reorder_qty'] = reorder_data['min_order_quantity']
    reorder_columns.append('reorder_qty')
    
    # Only include columns that exist
    available_columns = [col for col in reorder_columns if col in reorder_data.columns]
    
    return reorder_data[available_columns].to_csv(index=False).encode()

if __name__ == "__main__":
    render_reports_page()
</file>

<file path="data_manager.py">
import sqlite3
from contextlib import contextmanager
import pandas as pd
from datetime import datetime
import os
from barcode_handler import BarcodeHandler

class DataManager:

    def __init__(self):
        # Ensure database directory exists
        self.db_path = 'inventory.db'
        self.conn = sqlite3.connect(self.db_path, check_same_thread=False,
                               timeout=10)
        self.create_tables()
        print(f"Connected to database at {self.db_path}")

    @contextmanager
    def get_cursor(self):
        cursor = self.conn.cursor()
        try:
            yield cursor
        finally:
            cursor.close()

    def close(self):
        if hasattr(self, 'conn') and self.conn:
            self.conn.close()
            print("Database connection closed")
            
    def create_tables(self):
        with self.get_cursor() as cursor:
            try:
                # Create departments table (add this)
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS departments (
                        id INTEGER PRIMARY KEY,
                        code TEXT UNIQUE NOT NULL,
                        name TEXT NOT NULL,
                        parent_id INTEGER,
                        FOREIGN KEY (parent_id) REFERENCES departments (id)
                    )
                ''')

                # Create spare parts table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS spare_parts (
                        id INTEGER PRIMARY KEY,
                        part_number TEXT UNIQUE,
                        name TEXT,
                        description TEXT,
                        quantity INTEGER,
                        line_no INTEGER,
                        yard_no INTEGER,
                        page_no TEXT,
                        order_no TEXT,
                        material_code TEXT,
                        ilms_code TEXT,
                        item_denomination TEXT,
                        mustered BOOLEAN,
                        department_id INTEGER,
                        compartment_no TEXT,
                        box_no TEXT,
                        remark TEXT,
                        min_order_level INTEGER,
                        min_order_quantity INTEGER,
                        barcode TEXT UNIQUE,
                        last_updated TIMESTAMP
                    )
                ''')

                # Create transactions table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS transactions (
                        id INTEGER PRIMARY KEY,
                        part_id INTEGER,
                        transaction_type TEXT,
                        quantity INTEGER,
                        timestamp TIMESTAMP,
                        reason TEXT,
                        remarks TEXT,
                        FOREIGN KEY (part_id) REFERENCES spare_parts (id)
                    )
                ''')

                self.conn.commit()
                print("Database tables created successfully")
            except sqlite3.Error as e:
                print(f"Error creating tables: {e}")
                raise

    def update_department(self, dept_id, code, name, parent_id=None):
        with self.get_cursor() as cursor:
            try:
                # Prevent circular references
                if parent_id == dept_id:
                    return False, "Department cannot be its own parent"
                    
                cursor.execute('''
                    UPDATE departments 
                    SET code=?, name=?, parent_id=?
                    WHERE id=?
                ''', (code, name, parent_id, dept_id))
                self.conn.commit()
                return True, None
            except sqlite3.Error as e:
                return False, str(e)

    def delete_department(self, dept_id):
        with self.get_cursor() as cursor:
            try:
                # Check if department has children
                cursor.execute("SELECT COUNT(*) FROM departments WHERE parent_id=?", (dept_id,))
                child_count = cursor.fetchone()[0]
                if child_count > 0:
                    return False, "Cannot delete department with child departments"

                # Check if department is used in spare_parts
                cursor.execute("SELECT COUNT(*) FROM spare_parts WHERE department_id=?", (dept_id,))
                part_count = cursor.fetchone()[0]
                if part_count > 0:
                    return False, f"Cannot delete department - {part_count} inventory items reference it"

                cursor.execute("DELETE FROM departments WHERE id=?", (dept_id,))
                self.conn.commit()
                return True, None
            except sqlite3.Error as e:
                return False, str(e)

    def add_department(self, code, name, parent_id=None):
        with self.get_cursor() as cursor:
            try:
                cursor.execute('''
                    INSERT INTO departments (code, name, parent_id)
                    VALUES (?, ?, ?)
                ''', (code, name, parent_id))
                self.conn.commit()
                return True
            except sqlite3.IntegrityError:
                return False

    def get_all_departments_as_df(self):
        with self.get_cursor() as cursor:
            try:
                """Returns department data as a pandas DataFrame"""
                query = '''
                    SELECT d1.id, d1.code, d1.name, 
                        COALESCE(d2.name, 'Top Level') as parent_name
                    FROM departments d1
                    LEFT JOIN departments d2 ON d1.parent_id = d2.id
                    ORDER BY COALESCE(d1.parent_id, d1.id), d1.id
                '''
                return pd.read_sql_query(query, self.conn)
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving parts: {e}")
                return pd.DataFrame()

    def get_parent_options(self):
        with self.get_cursor() as cursor:
            """Returns options for parent department dropdown"""
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT id, name FROM departments WHERE parent_id IS NULL
            ''')
            return cursor.fetchall()
    
    def get_department_info(self, department_id):
        with self.get_cursor() as cursor:
            """Get department hierarchy info for a department ID"""
            query = '''
                SELECT d1.name as parent_department,
                    d2.name as child_department
                FROM departments d2
                LEFT JOIN departments d1 ON d2.parent_id = d1.id
                WHERE d2.id = ?
            '''
            result = pd.read_sql_query(query, self.conn, params=(department_id,))
            return result.iloc[0] if not result.empty else None
    
    def get_parent_departments(self):
        with self.get_cursor() as cursor:
            """Get all parent departments"""
            query = "SELECT id, name FROM departments WHERE parent_id IS NULL"
            return pd.read_sql_query(query, self.conn)

    def get_child_departments(self, parent_id):
        """Get child departments for a given parent"""
        if not parent_id:
            return pd.DataFrame(columns=['id', 'name'])
        query = "SELECT id, name FROM departments WHERE parent_id = ?"
        return pd.read_sql_query(query, self.conn, params=(parent_id,))
    
    def bulk_import_spare_parts(self, df, department_id, parent_dept_id):
        """Bulk import spare parts from DataFrame with department assignment"""
        
        results = []
        with self.get_cursor() as cursor:  # Use context manager
            try:
                records = df.to_dict('records')
                cursor.execute("BEGIN TRANSACTION")            
                
                for idx, record in enumerate(records, start=1):
                    result = {
                        'row_number': idx,
                        'part_number': record.get('part_number', ''),
                        'name': record.get('name', ''),
                        'status': 'pending',
                        'message': ''
                    }
                    
                    try:
                        # Validate required fields
                        if not record.get('part_number'):
                            raise ValueError("Part number is required")
                        if not record.get('name'):
                            raise ValueError("Name is required")
                        if not isinstance(record.get('quantity', 0), (int, float)):
                            raise ValueError("Quantity must be a number")
                        # Check barcode uniqueness if provided
                        if 'barcode' in record and record['barcode']:
                            cursor.execute("SELECT 1 FROM spare_parts WHERE barcode=?", (record['barcode'],))
                            if cursor.fetchone():
                                raise ValueError(f"Barcode {record['barcode']} already exists in database")
                        if not record.get('barcode'):
                            raise ValueError("Barcode is required")
                        # Generate barcode if not provided
                        #if 'barcode' not in record or pd.isna(record.get('barcode')) or not record.get('barcode'):
                            # Get last serial number from database
                        #    last_serial = get_last_serial_number(department_id)
                        #    record['barcode'] = BarcodeHandler.generate_unique_barcode()
                        
                        # Set default values
                        record['department_id'] = department_id
                        record['min_order_level'] = record.get('min_order_level', 0)
                        record['min_order_quantity'] = record.get('min_order_quantity', 1)
                        record['compartment_no'] = record.get('compartment_no', '')
                        record['last_updated'] = datetime.now()
                        
                        # Ensure all required fields have values
                        record['part_number'] = str(record['part_number'])
                        record['name'] = str(record['name'])
                        record['quantity'] = int(record['quantity'])
                        record['line_no'] = int(record.get('line_no', 0))
                        #record['yard_no'] = int(record.get('yard_no', 0))
                        
                        cursor.execute('''
                            INSERT OR REPLACE INTO spare_parts (
                                part_number, name, description, quantity,
                                line_no, page_no, order_no,
                                material_code, ilms_code, item_denomination,
                                mustered, department_id, compartment_no,
                                box_no, remark, min_order_level,
                                min_order_quantity, barcode, last_updated, status
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                        ''', (
                            record['part_number'],
                            record['name'],
                            record.get('description', ''),
                            record['quantity'],
                            record['line_no'],
                            str(record.get('page_no', '')),
                            str(record.get('order_no', '')),
                            str(record.get('material_code', '')),
                            str(record.get('ilms_code', '')),
                            str(record.get('item_denomination', '')),
                            bool(record.get('mustered', False)),
                            record['department_id'],
                            str(record.get('compartment_name', '')),
                            str(record.get('box_no', '')),
                            str(record.get('remark', '')),
                            int(record.get('min_order_level', 0)),
                            int(record.get('min_order_quantity', 1)),
                            record['barcode'],
                            record['last_updated'],
                            'In Store'
                        ))
                        result['status'] = 'success'
                        result['message'] = 'Imported successfully'
                    
                    except Exception as e:
                        self.conn.rollback()
                        cursor.execute("BEGIN TRANSACTION")  # Restart transaction for next record
                        result['status'] = 'failed'
                        result['message'] = str(e)
                        
                    results.append(result)
                
                self.conn.commit()
                return results, True, f"Successfully imported {len([r for r in results if r['status'] == 'success'])}/{len(records)} records"
            except Exception as e:
                self.conn.rollback()
                result = [{
                    'row_number': 0,
                    'part_number': '',
                    'name': '',
                    'status': 'failed',
                    'message': f"Global error: {str(e)}"
                }]
                return results, False, f"Error during import: {str(e)}"            
    
    def add_spare_part(self, part_data):
        with self.get_cursor() as cursor:
            try:
                cursor.execute(
                    '''
                    INSERT INTO spare_parts (part_number, name, description, quantity,
                    line_no, page_no, order_no, material_code, ilms_code, item_denomination,
                    mustered, department_id, compartment_no,  box_no, remark, 
                    min_order_level, min_order_quantity, barcode, last_updated, status,
                    last_maintenance_date, next_maintenance_date)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''',
                    (part_data['part_number'], part_data['name'],
                    part_data['description'], part_data['quantity'],
                    part_data['line_no'], part_data['page_no'], part_data['order_no'],
                    part_data['material_code'], part_data['ilms_code'],
                    part_data['item_denomination'], part_data['mustered'],
                    part_data['department_id'], part_data['compartment_no'],
                    part_data['box_no'], part_data['remark'],
                    part_data['min_order_level'], part_data['min_order_quantity'],
                    part_data['barcode'], datetime.now(), 
                    part_data['status'], part_data['last_maintenance_date'],
                    part_data['next_maintenance_date']))
                self.conn.commit()
                return True
            except sqlite3.IntegrityError:
                return False
            except sqlite3.Error as e:
                print(f"Error adding spare part: {e}")
                return False

    def update_spare_part(self, part_id, part_data):
        with self.get_cursor() as cursor:
            cursor.execute(
                '''
                UPDATE spare_parts 
                SET name=?, description=?, quantity=?, min_order_level=?,
                    min_order_quantity=?, last_updated=?, location=?, status=?,
                    last_maintenance_date=?, next_maintenance_date=?
                WHERE id=?
            ''', (part_data['name'], part_data['description'],
                part_data['quantity'], part_data['min_order_level'],
                part_data['min_order_quantity'], datetime.now(), part_data['location'],
                part_data['status'], part_data['last_maintenance_date'],
                part_data['next_maintenance_date'], part_id))
            self.conn.commit()

    def get_parts_by_department(self, department_id):
        """Get all parts for a specific department"""
        with self.get_cursor() as cursor:
            try:
                query = '''
                    SELECT sp.*, 
                        d1.name as parent_department,
                        d2.name as child_department
                    FROM spare_parts sp
                    LEFT JOIN departments d2 ON sp.department_id = d2.id
                    LEFT JOIN departments d1 ON d2.parent_id = d1.id
                    WHERE sp.department_id = ?
                    ORDER BY sp.name
                '''
                df =  pd.read_sql_query(query, self.conn, params=(department_id,))
                return df
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving parts: {e}")
                return pd.DataFrame()
    
    def get_all_parts(self):
        with self.get_cursor() as cursor:
            try:
                query = '''
                    SELECT s.*, 
                        dp.name as parent_department,
                        dc.name as child_department
                    FROM spare_parts s
                    LEFT JOIN departments dc ON s.department_id = dc.id
                    LEFT JOIN departments dp ON dc.parent_id = dp.id
                '''
                df = pd.read_sql_query(query, self.conn)
                return df
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving parts: {e}")
                return pd.DataFrame()

    def get_part_by_id(self, part_id):
        with self.get_cursor() as cursor:
            try:
                df = pd.read_sql_query(
                    f"SELECT * FROM spare_parts WHERE id= {part_id}", self.conn)
                if df.empty:
                    print(f"No part found with ID {part_id}")
                    return None
                return df
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving part {part_id}: {e}")
                return None
        
    def is_barcode_unique(self, barcode):
        with self.get_cursor() as cursor:
            """Check if barcode already exists"""
            query = "SELECT 1 FROM spare_parts WHERE barcode = ?"
            result = pd.read_sql_query(query, self.conn, params=(barcode,))
            return result.empty

    def get_last_serial_number(self, dept_id):
        with self.get_cursor() as cursor:
            """Get the highest serial number from existing barcodes"""
            query = f"""
            SELECT barcode FROM spare_parts 
            WHERE barcode LIKE '%-%-%' and department_id= {dept_id}
            ORDER BY barcode DESC 
            LIMIT 1
            """
            result = pd.read_sql_query(query, self.conn)
            
            if not result.empty:
                last_barcode = result.iloc[0]['barcode']
                try:
                    return int(last_barcode.split('-')[-1])
                except (IndexError, ValueError):
                    return 0
            return 0

    def get_last_piece_stock_items(self):
        with self.get_cursor() as cursor:
            try:
                return pd.read_sql_query(
                    "SELECT * FROM spare_parts WHERE quantity = 1",
                    self.conn)
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving low stock items: {e}")
                return pd.DataFrame()
        
    def get_last_piece_stock_items_by_dept(self, department_id):
        with self.get_cursor() as cursor:
            try:
                return pd.read_sql_query(
                    "SELECT * FROM spare_parts WHERE department_id = ?  AND quantity = 1",
                    self.conn, params=(department_id,))
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving low stock items: {e}")
                return pd.DataFrame()
        
    def get_low_stock_items(self):
        with self.get_cursor() as cursor:
            try:
                return pd.read_sql_query(
                    "SELECT * FROM spare_parts WHERE quantity <= min_order_level AND quantity > 1",
                    self.conn)
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving low stock items: {e}")
                return pd.DataFrame()
        
    def get_low_stock_items_by_dept(self, department_id):
        with self.get_cursor() as cursor:
            try:
                return pd.read_sql_query(
                    "SELECT * FROM spare_parts WHERE department_id = ? AND quantity <= min_order_level AND quantity > 1",
                    self.conn, params=(department_id,))
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving low stock items: {e}")
                return pd.DataFrame()

    def record_transaction(self, part_id, transaction_type, quantity, reason, remarks):
        with self.get_cursor() as cursor:
            try:
                # First verify the part exists and has enough stock
                # print(f"recording transaction: {part_id}")  # hari
                part_df = self.get_part_by_id(part_id)
                if part_df is None or part_df.empty:
                    raise ValueError(f"Part with ID {part_id} not found")

                part = part_df.iloc[0]
                current_quantity = int(part['quantity'])
                selected_part = int(part_id)

                if transaction_type == 'check_out' and current_quantity < quantity:
                    raise ValueError(
                        f"Insufficient stock. Available: {current_quantity}, Requested: {quantity}"
                    )

                # Record the transaction
                cursor.execute(
                    '''
                    INSERT INTO transactions (part_id, transaction_type, quantity, timestamp, reason, remarks)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (selected_part, transaction_type, quantity, datetime.now(), reason, remarks))

                print(f"Recorded transaction: {transaction_type}")

                # Update stock quantity
                update_quantity = -quantity if transaction_type == 'check_out' else quantity
                cursor.execute(
                    '''
                    UPDATE spare_parts 
                    SET quantity = quantity + ?, last_updated = ?
                    WHERE id = ?
                ''', (update_quantity, datetime.now(), selected_part))

                self.conn.commit()
                return True, None  # Success, no error message
            except (sqlite3.Error, ValueError) as e:
                print(f"Error recording transaction: {e}")
                self.conn.rollback()
                return False, str(e)  # Return error status and message

    def get_transaction_history(self, days=30):
        with self.get_cursor() as cursor:
            query = '''
                SELECT t.*, sp.name, sp.part_number, 
                    d1.name as parent_department,
                    d2.name as child_department
                FROM transactions t
                JOIN spare_parts sp ON t.part_id = sp.id
                LEFT JOIN departments d2 ON sp.department_id = d2.id
                LEFT JOIN departments d1 ON d2.parent_id = d1.id
                WHERE t.timestamp >= date('now', ?)
            '''
            try:
                return pd.read_sql_query(query,
                                        self.conn,
                                        params=[f'-{days} days'])
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving transaction history: {e}")
                return pd.DataFrame()
        
    def get_transaction_history_by_department(self, department_id, days=30):
        with self.get_cursor() as cursor:
            """Get all parts for a specific department"""
            try:
                cursor = self.conn.cursor()
                query = '''
                    SELECT t.*, sp.name, sp.part_number, 
                        d1.name as parent_department,
                        d2.name as child_department
                    FROM transactions t
                    JOIN spare_parts sp ON t.part_id = sp.id
                    LEFT JOIN departments d2 ON sp.department_id = d2.id
                    LEFT JOIN departments d1 ON d2.parent_id = d1.id
                    WHERE t.timestamp >= date('now', ?) and sp.department_id = ?
                    ORDER BY sp.name
                '''
                df =  pd.read_sql_query(query, self.conn, params=(f'-{days} days', department_id,))
                return df
            except pd.io.sql.DatabaseError as e:
                print(f"Error retrieving parts: {e}")
                return pd.DataFrame()
</file>

<file path="pages/analytics.py">
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import plotly.subplots as sp
from plotly.colors import qualitative
import numpy as np
from datetime import datetime, timedelta
from user_management import login_required, init_session_state
import navbar
from app_settings import set_page_configuration
from data_manager import DataManager

set_page_configuration()

current_page = "Analytics"
st.header(current_page)

# Initialize session state
init_session_state()

navbar.nav(current_page)

@login_required
def render_analytics_page():
    st.title("üìä Advanced Inventory Analytics")
    
    # Initialize session state
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    
    # Date range selector
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        date_range = st.selectbox(
            "Analysis Period",
            ["Last 30 Days", "Last 90 Days", "Last 6 Months", "Last Year", "Custom"],
            index=1
        )
    
    with col2:
        if date_range == "Custom":
            start_date = st.date_input("Start Date", datetime.now() - timedelta(days=90))
            end_date = st.date_input("End Date", datetime.now())
        else:
            days_map = {
                "Last 30 Days": 30,
                "Last 90 Days": 90,
                "Last 6 Months": 180,
                "Last Year": 365
            }
            days = days_map.get(date_range, 90)
    
    with col3:
        analysis_focus = st.selectbox(
            "Focus Area",
            ["Overall Performance", "Stock Optimization", "Demand Forecasting", "Cost Analysis", "Department Analysis"]
        )
    
    # Department selection for data filtering
    st.subheader("üîç Data Selection")
    
    # Get current user's role and department
    current_user_role = st.session_state.get('user_role')
    current_user_dept_id = st.session_state.get('user_department_id')
    
    selected_child = None
    selected_parent = None
    
    if current_user_role == 'User':
        # Regular users can only see their own department
        selected_child = current_user_dept_id
        if selected_child:
            dept_info = st.session_state.data_manager.get_department_info(selected_child)
            if dept_info is not None and not dept_info.empty:
                st.info(f"üìã Viewing data for: {dept_info['child_department']} - {dept_info['parent_department']}")
    else:
        # Admin/Super User can select departments
        cols = st.columns(2)
        
        with cols[0]:
            # Department selection
            parent_depts = st.session_state.data_manager.get_parent_departments()
            if not parent_depts.empty:
                selected_parent = st.selectbox(
                    "Select Parent Department",
                    parent_depts['id'].tolist(),
                    index=0,
                    placeholder="Select Parent Department",
                    format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                    key="analytics_parent_dept"
                )
        
        with cols[1]:
            if selected_parent:
                child_depts = st.session_state.data_manager.get_child_departments(selected_parent)
                if not child_depts.empty:                                
                    selected_child = st.selectbox(
                        "Select Child Department",
                        child_depts['id'].tolist(),
                        index=0,
                        placeholder="Select Child Department",
                        format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                        key="analytics_child_dept"
                    )
    
    # Get data with consistency checks
    df = pd.DataFrame()
    transactions = pd.DataFrame()
    
    if selected_child is not None:
        df = st.session_state.data_manager.get_parts_by_department(selected_child)
        # Use selected_parent if available, otherwise use the parent of selected_child
        if selected_parent:
            parent_id_for_transactions = selected_parent
        else:
            # Get parent department from child department
            dept_info = st.session_state.data_manager.get_department_info(selected_child)
            if dept_info is not None and not dept_info.empty and 'parent_id' in dept_info:
                parent_id_for_transactions = dept_info['parent_id']
            else:
                parent_id_for_transactions = selected_child  # fallback
        
        transactions = st.session_state.data_manager.get_transaction_history_by_department(parent_id_for_transactions, days=90)
        
        # Ensure data consistency
        df = ensure_data_consistency(df)
        transactions = ensure_data_consistency(transactions)
    else:
        # If no department selected, get all data (for Admin/Super User)
        if current_user_role in ['Admin', 'Super User']:
            df = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=90)
            
            # Ensure data consistency
            df = ensure_data_consistency(df)
            transactions = ensure_data_consistency(transactions)
        else:
            st.warning("Please contact administrator to assign you to a department.")
            return

    # Main analytics tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üìà Overview Dashboard", 
        "üîç Stock Analysis", 
        "üìä Demand Insights", 
        "üí∞ Cost Analytics",
        "üìã Detailed Reports"
    ])

    with tab1:
        render_overview_dashboard(days if date_range != "Custom" else (end_date - start_date).days, 
                                selected_child, current_user_role)
    
    with tab2:
        render_stock_analysis(days if date_range != "Custom" else (end_date - start_date).days, 
                            selected_child, current_user_role)
    
    with tab3:
        render_demand_insights(days if date_range != "Custom" else (end_date - start_date).days, 
                             selected_child, current_user_role)
    
    with tab4:
        render_cost_analytics(days if date_range != "Custom" else (end_date - start_date).days, 
                            selected_child, current_user_role)
    
    with tab5:
        render_detailed_reports(days if date_range != "Custom" else (end_date - start_date).days, 
                              selected_child, current_user_role)

def render_overview_dashboard(days, department_id, user_role):
    """Overview dashboard with performance metrics"""
    st.subheader("üèÜ Performance Overview")
    
    # Get data based on user role and department
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    # Ensure data consistency
    spare_parts = ensure_data_consistency(spare_parts)
    transactions = ensure_data_consistency(transactions)
    
    if spare_parts.empty:
        st.warning("No inventory data available for analysis")
        return
    
    # KPI Metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        stock_turnover = calculate_stock_turnover_rate(transactions, spare_parts)
        st.metric(
            "Stock Turnover Rate", 
            f"{stock_turnover:.1f}x",
            delta=f"{calculate_turnover_trend(transactions):.1f}x"
        )
    
    with col2:
        service_level = calculate_service_level(transactions)
        st.metric(
            "Service Level", 
            f"{service_level:.1f}%",
            delta=f"{service_level - 95:.1f}%"
        )
    
    with col3:
        critical_items = len(spare_parts[spare_parts['quantity'] <= spare_parts['min_order_level']])
        st.metric(
            "Critical Items", 
            critical_items,
            delta=critical_items - len(spare_parts[spare_parts['quantity'] == 0]),
            delta_color="inverse"
        )
    
    # Charts Row 1
    chart_col1, chart_col2 = st.columns(2)
    
    with chart_col1:
        fig = create_monthly_trend_chart(transactions)
        st.plotly_chart(fig, use_container_width=True)
    
    with chart_col2:
        fig = create_inventory_health_chart(spare_parts)
        st.plotly_chart(fig, use_container_width=True)
    
    # Charts Row 2
    chart_col3, chart_col4 = st.columns(2)
    
    with chart_col3:
        fig = create_department_performance_chart(transactions, spare_parts)
        st.plotly_chart(fig, use_container_width=True)
    
    with chart_col4:
        fig = create_abc_analysis_chart(spare_parts)
        st.plotly_chart(fig, use_container_width=True)

def render_stock_analysis(days, department_id, user_role):
    """Stock optimization analysis"""
    st.subheader("üîç Stock Optimization Analysis")
    
    # Get data based on access
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    # Ensure data consistency
    spare_parts = ensure_data_consistency(spare_parts)
    transactions = ensure_data_consistency(transactions)
    
    if spare_parts.empty:
        st.warning("No inventory data available for analysis")
        return
    
    # Stock optimization metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        excess_stock = calculate_excess_stock_value(spare_parts)
        st.metric("Excess Stock Value", f"${excess_stock:,.0f}")
    
    with col2:
        stockout_risk = calculate_stockout_risk(spare_parts)
        st.metric("High Stockout Risk Items", stockout_risk)
    
    with col3:
        optimal_level = calculate_optimal_stock_level(spare_parts)
        st.metric("Optimal Stock Achievement", f"{optimal_level:.1f}%")
    
    # Stock analysis charts
    tab1, tab2, tab3 = st.tabs(["ABC Analysis", "Stock Levels", "Reorder Analysis"])
    
    with tab1:
        col1, col2 = st.columns([2, 1])
        with col1:
            st.plotly_chart(create_detailed_abc_chart(spare_parts), use_container_width=True)
        with col2:
            abc_summary = calculate_abc_summary(spare_parts)
            st.dataframe(abc_summary, use_container_width=True)
    
    with tab2:
        st.plotly_chart(create_stock_level_analysis_chart(spare_parts), use_container_width=True)
        
        # Stock level recommendations
        st.subheader("üìã Stock Level Recommendations")
        recommendations = generate_stock_recommendations(spare_parts)
        for rec in recommendations:
            with st.expander(f"{rec['type']} - {rec['count']} items"):
                st.write(rec['description'])
                if not rec['items'].empty:
                    st.dataframe(rec['items'][['name', 'quantity', 'min_order_level', 'recommended_action']], 
                               use_container_width=True)
    
    with tab3:
        st.plotly_chart(create_reorder_analysis_chart(spare_parts, transactions), use_container_width=True)

def render_demand_insights(days, department_id, user_role):
    """Demand pattern analysis"""
    st.subheader("üìä Demand Pattern Analysis")
    
    # Get data based on access
    if user_role == 'User':
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
    else:
        if department_id:
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        else:
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
            spare_parts = st.session_state.data_manager.get_all_parts()
    
    # Ensure data consistency
    transactions = ensure_data_consistency(transactions)
    spare_parts = ensure_data_consistency(spare_parts)
    
    if transactions.empty:
        st.warning("No transaction data available for demand analysis")
        return
    
    # Demand metrics
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        avg_daily_demand = calculate_average_daily_demand(transactions)
        st.metric("Avg Daily Demand", f"{avg_daily_demand:.0f} units")
    
    with col2:
        demand_variability = calculate_demand_variability(transactions)
        st.metric("Demand Variability", f"{demand_variability:.2f}")
    
    with col3:
        peak_demand = identify_peak_demand(transactions)
        st.metric("Peak Demand Period", peak_demand)
    
    with col4:
        seasonal_trend = detect_seasonal_trend(transactions)
        st.metric("Seasonal Trend", seasonal_trend)
    
    # Demand forecasting
    st.subheader("üîÆ Demand Forecasting")
    
    forecast_col1, forecast_col2 = st.columns(2)
    
    with forecast_col1:
        if not spare_parts.empty:
            selected_part = st.selectbox(
                "Select Item for Forecasting",
                spare_parts['name'].unique()[:20]  # Limit to first 20 for performance
            )
            
            if selected_part:
                part_data = spare_parts[spare_parts['name'] == selected_part].iloc[0]
                part_transactions = transactions[transactions['name'] == selected_part]
                
                if not part_transactions.empty:
                    st.plotly_chart(create_demand_forecast_chart(part_transactions, part_data), 
                                  use_container_width=True)
                else:
                    st.info("No transaction history for selected item")
        else:
            st.info("No inventory items available")
    
    with forecast_col2:
        st.plotly_chart(create_demand_pattern_chart(transactions), use_container_width=True)
    
    # Additional demand insights
    st.subheader("üìà Demand Insights")
    
    insight_col1, insight_col2 = st.columns(2)
    
    with insight_col1:
        st.plotly_chart(create_weekly_demand_pattern(transactions), use_container_width=True)
    
    with insight_col2:
        st.plotly_chart(create_demand_correlation_heatmap(transactions), use_container_width=True)

def render_cost_analytics(days, department_id, user_role):
    """Cost and value analytics"""
    st.subheader("üí∞ Cost and Value Analytics")
    
    # Get data based on access
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    # Ensure data consistency
    spare_parts = ensure_data_consistency(spare_parts)
    transactions = ensure_data_consistency(transactions)
    
    # Cost metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        carrying_cost = calculate_carrying_cost(spare_parts)
        st.metric("Carrying Cost (Annual)", f"${carrying_cost:,.0f}")
    
    with col2:
        stockout_cost = estimate_stockout_cost(transactions, spare_parts)
        st.metric("Estimated Stockout Cost", f"${stockout_cost:,.0f}")
    
    with col3:
        eoq_savings = calculate_eoq_savings(spare_parts)
        st.metric("EOQ Potential Savings", f"${eoq_savings:,.0f}")
    
    # Cost analysis charts
    cost_col1, cost_col2 = st.columns(2)
    
    with cost_col1:
        st.plotly_chart(create_cost_analysis_chart(spare_parts), use_container_width=True)
    
    with cost_col2:
        st.plotly_chart(create_value_distribution_chart(spare_parts), use_container_width=True)
    
    # Cost optimization recommendations
    st.subheader("üí° Cost Optimization Opportunities")
    
    recommendations = generate_cost_recommendations(spare_parts, transactions)
    for i, rec in enumerate(recommendations):
        with st.expander(f"Opportunity {i+1}: {rec['title']}"):
            st.write(f"**Potential Savings:** ${rec['savings']:,.0f}")
            st.write(rec['description'])
            st.write(f"**Implementation:** {rec['implementation']}")

def render_detailed_reports(days, department_id, user_role):
    """Detailed analytical reports"""
    st.subheader("üìã Detailed Analytical Reports")
    
    report_type = st.selectbox(
        "Select Report Type",
        [
            "Inventory Performance Report",
            "Stock Optimization Report", 
            "Demand Analysis Report",
            "Cost Analysis Report",
            "Department Performance Report"
        ]
    )
    
    if report_type == "Inventory Performance Report":
        generate_inventory_performance_report(days, department_id, user_role)
    elif report_type == "Stock Optimization Report":
        generate_stock_optimization_report(days, department_id, user_role)
    elif report_type == "Demand Analysis Report":
        generate_demand_analysis_report(days, department_id, user_role)
    elif report_type == "Cost Analysis Report":
        generate_cost_analysis_report(days, department_id, user_role)
    elif report_type == "Department Performance Report":
        generate_department_performance_report(days, department_id, user_role)

# =============================================================================
# CHART CREATION FUNCTIONS
# =============================================================================

def create_monthly_trend_chart(transactions):
    """Create monthly transaction trend chart"""
    if transactions.empty:
        return create_empty_chart("No transaction data available")
    
    transactions = transactions.copy()
    transactions['timestamp'] = pd.to_datetime(transactions['timestamp'])
    monthly_data = transactions.groupby([
        transactions['timestamp'].dt.to_period('M'),
        'transaction_type'
    ]).size().reset_index(name='count')
    
    monthly_data['timestamp'] = monthly_data['timestamp'].dt.to_timestamp()
    
    fig = px.line(
        monthly_data, 
        x='timestamp', 
        y='count', 
        color='transaction_type',
        title="üìà Monthly Transaction Trends",
        labels={'count': 'Number of Transactions', 'timestamp': 'Month'},
        color_discrete_map={'check_in': '#00CC96', 'check_out': '#EF553B'}
    )
    
    fig.update_layout(
        hovermode='x unified',
        showlegend=True,
        height=400
    )
    
    return fig

def create_inventory_health_chart(spare_parts):
    """Create inventory health status chart"""
    if spare_parts.empty:
        return create_empty_chart("No inventory data available")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Create health status using pandas operations instead of np.select
    health_status = []
    for _, row in spare_parts.iterrows():
        quantity = row['quantity']
        min_order_level = row['min_order_level']
        
        if quantity == 0:
            health_status.append('Out of Stock')
        elif quantity == 1:
            health_status.append('Last Piece')
        elif quantity <= min_order_level:
            health_status.append('Low Stock')
        else:
            health_status.append('Healthy')
    
    spare_parts['health_status'] = health_status
    
    health_counts = spare_parts['health_status'].value_counts()
    
    fig = px.pie(
        values=health_counts.values,
        names=health_counts.index,
        title="ü©∫ Inventory Health Status",
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    
    fig.update_traces(textposition='inside', textinfo='percent+label')
    fig.update_layout(height=400, showlegend=False)
    
    return fig

def create_department_performance_chart(transactions, spare_parts):
    """Create department performance comparison chart"""
    if transactions.empty or spare_parts.empty:
        return create_empty_chart("Insufficient data for department analysis")
    
    # Create a copy to avoid modifying original data
    transactions = transactions.copy()
    spare_parts = spare_parts.copy()
    
    # Check if child_department exists in spare_parts, if not try to get it
    if 'child_department' not in spare_parts.columns:
        # Try to get department information
        if 'department_id' in spare_parts.columns:
            # Create a mapping from department_id to department name
            dept_mapping = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_info = st.session_state.data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_mapping[dept_id] = f'Dept_{dept_id}'
            
            spare_parts['child_department'] = spare_parts['department_id'].map(dept_mapping)
        else:
            # If no department info available, use a default
            spare_parts['child_department'] = 'General Department'
    
    # Ensure we have the required columns for merging
    if 'part_id' not in transactions.columns and 'id' in spare_parts.columns:
        # If transactions has part_id but it's called differently, adjust accordingly
        # This is a fallback - you might need to adjust based on your actual column names
        pass
    
    # Merge to get department information - handle different possible column names
    merge_successful = False
    merged_data = transactions.copy()
    
    # Try different possible merge strategies
    if 'part_id' in transactions.columns and 'id' in spare_parts.columns:
        merged_data = transactions.merge(
            spare_parts[['id', 'child_department']], 
            left_on='part_id', 
            right_on='id', 
            how='left'
        )
        merge_successful = True
    elif 'name' in transactions.columns and 'name' in spare_parts.columns:
        # Merge by name as fallback
        merged_data = transactions.merge(
            spare_parts[['name', 'child_department']], 
            on='name', 
            how='left'
        )
        merge_successful = True
    
    if not merge_successful or 'child_department' not in merged_data.columns:
        # If merge failed or child_department still doesn't exist, create a default
        merged_data['child_department'] = 'General Department'
    
    # Fill any NaN values in child_department
    merged_data['child_department'] = merged_data['child_department'].fillna('Unknown Department')
    
    # Now group by department
    dept_performance = merged_data.groupby('child_department').agg({
        'quantity': ['sum', 'count'],
        'part_id': 'nunique'
    }).round(2)
    
    # Flatten column names
    dept_performance.columns = ['total_quantity', 'transaction_count', 'unique_items']
    dept_performance = dept_performance.reset_index()
    
    fig = px.bar(
        dept_performance,
        x='child_department',
        y='transaction_count',
        title="üèóÔ∏è Department Activity Comparison",
        labels={'child_department': 'Department', 'transaction_count': 'Transaction Count'},
        color='total_quantity',
        color_continuous_scale='Viridis'
    )
    
    fig.update_layout(height=400, xaxis_tickangle=-45)
    return fig

def create_abc_analysis_chart(spare_parts):
    """Create ABC analysis chart"""
    if spare_parts.empty:
        return create_empty_chart("No data for ABC analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Simple ABC analysis based on quantity and criticality
    spare_parts['value_score'] = spare_parts['quantity'] * spare_parts['min_order_level']
    spare_parts = spare_parts.sort_values('value_score', ascending=False)
    spare_parts['cumulative_percentage'] = spare_parts['value_score'].cumsum() / spare_parts['value_score'].sum() * 100
    
    # Use explicit logic instead of np.select
    abc_class = []
    for cum_pct in spare_parts['cumulative_percentage']:
        if cum_pct <= 80:
            abc_class.append('A - High Value')
        elif cum_pct <= 95:
            abc_class.append('B - Medium Value')
        else:
            abc_class.append('C - Low Value')
    
    spare_parts['abc_class'] = abc_class
    
    abc_counts = spare_parts['abc_class'].value_counts()
    
    fig = px.bar(
        x=abc_counts.index,
        y=abc_counts.values,
        title="üìä ABC Analysis - Inventory Classification",
        labels={'x': 'ABC Class', 'y': 'Number of Items'},
        color=abc_counts.index,
        color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1']
    )
    
    fig.update_layout(height=400, showlegend=False)
    return fig

def create_detailed_abc_chart(spare_parts):
    """Create detailed ABC analysis with Pareto chart"""
    if spare_parts.empty:
        return create_empty_chart("No data for detailed ABC analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Calculate value (simplified - in real scenario use actual costs)
    spare_parts['estimated_value'] = spare_parts['quantity'] * spare_parts['min_order_level'] * 10
    spare_parts = spare_parts.sort_values('estimated_value', ascending=False)
    spare_parts['cumulative_percentage'] = spare_parts['estimated_value'].cumsum() / spare_parts['estimated_value'].sum() * 100
    
    # Create Pareto chart
    fig = go.Figure()
    
    # Get top 20 items or all if less than 20
    top_items = spare_parts.head(20)
    
    # Bar chart for individual values
    fig.add_trace(go.Bar(
        x=top_items['name'],
        y=top_items['estimated_value'],
        name='Item Value',
        marker_color='lightblue'
    ))
    
    # Line chart for cumulative percentage
    fig.add_trace(go.Scatter(
        x=top_items['name'],
        y=top_items['cumulative_percentage'],
        name='Cumulative %',
        yaxis='y2',
        line=dict(color='red', width=2),
        marker=dict(size=8)
    ))
    
    fig.update_layout(
        title='üìà Pareto Analysis - Top 20 Items',
        xaxis=dict(title='Items', tickangle=45),
        yaxis=dict(title='Estimated Value ($)', side='left'),
        yaxis2=dict(title='Cumulative Percentage', overlaying='y', side='right', range=[0, 100]),
        height=500,
        showlegend=True
    )
    
    return fig

def create_stock_level_analysis_chart(spare_parts):
    """Create comprehensive stock level analysis chart"""
    if spare_parts.empty:
        return create_empty_chart("No data for stock level analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Handle department column
    if 'child_department' not in spare_parts.columns:
        if 'department_id' in spare_parts.columns:
            # Create department mapping
            dept_mapping = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_info = st.session_state.data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_mapping[dept_id] = f'Dept_{dept_id}'
            spare_parts['child_department'] = spare_parts['department_id'].map(dept_mapping)
        else:
            spare_parts['child_department'] = 'General'
    
    fig = px.scatter(
        spare_parts,
        x='quantity',
        y='min_order_level',
        size='min_order_quantity',
        color='child_department',
        title="üîç Stock Level vs Minimum Order Level Analysis",
        labels={
            'quantity': 'Current Quantity',
            'min_order_level': 'Minimum Order Level',
            'min_order_quantity': 'Order Quantity',
            'child_department': 'Department'
        },
        hover_data=['name', 'part_number']
    )
    
    # Add reference lines
    if not spare_parts.empty:
        fig.add_hline(y=spare_parts['min_order_level'].median(), line_dash="dash", line_color="red")
        fig.add_vline(x=spare_parts['quantity'].median(), line_dash="dash", line_color="blue")
    
    fig.update_layout(height=500)
    return fig

def create_demand_forecast_chart(part_transactions, part_data):
    """Create demand forecast chart for a specific part"""
    if part_transactions.empty:
        return create_empty_chart("No transaction data for forecasting")
    
    part_transactions = part_transactions.copy()
    part_transactions['timestamp'] = pd.to_datetime(part_transactions['timestamp'])
    daily_demand = part_transactions.groupby(part_transactions['timestamp'].dt.date)['quantity'].sum()
    
    # Simple moving average forecast
    forecast_days = 30
    if len(daily_demand) > 7:
        ma_7 = daily_demand.rolling(window=7).mean()
        
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=daily_demand.index,
            y=daily_demand.values,
            name='Actual Demand',
            line=dict(color='blue', width=2)
        ))
        
        fig.add_trace(go.Scatter(
            x=ma_7.index,
            y=ma_7.values,
            name='7-Day Moving Average',
            line=dict(color='red', width=2, dash='dash')
        ))
        
        fig.update_layout(
            title=f"üîÆ Demand Forecast: {part_data['name']}",
            xaxis_title='Date',
            yaxis_title='Quantity',
            height=400,
            showlegend=True
        )
    else:
        fig = create_empty_chart("Insufficient data for reliable forecasting")
    
    return fig

def create_demand_pattern_chart(transactions):
    """Create overall demand pattern analysis"""
    if transactions.empty:
        return create_empty_chart("No transaction data for pattern analysis")
    
    transactions = transactions.copy()
    transactions['timestamp'] = pd.to_datetime(transactions['timestamp'])
    transactions['day_of_week'] = transactions['timestamp'].dt.day_name()
    transactions['hour'] = transactions['timestamp'].dt.hour
    
    daily_pattern = transactions.groupby('day_of_week').size()
    
    days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    daily_pattern = daily_pattern.reindex(days_order)
    
    fig = px.line(
        x=daily_pattern.index,
        y=daily_pattern.values,
        title="üìÖ Weekly Demand Pattern",
        labels={'x': 'Day of Week', 'y': 'Transaction Count'}
    )
    
    fig.update_layout(height=400)
    return fig

def create_cost_analysis_chart(spare_parts):
    """Create cost analysis and distribution chart"""
    if spare_parts.empty:
        return create_empty_chart("No data for cost analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Simplified cost calculation (replace with actual cost data)
    spare_parts['estimated_cost'] = spare_parts['quantity'] * spare_parts['min_order_level'] * 5
    
    # Handle department column for treemap
    if 'child_department' not in spare_parts.columns:
        if 'department_id' in spare_parts.columns:
            dept_mapping = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_info = st.session_state.data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_mapping[dept_id] = f'Dept_{dept_id}'
            spare_parts['child_department'] = spare_parts['department_id'].map(dept_mapping)
        else:
            spare_parts['child_department'] = 'General'
    
    # Check if we have valid department data for treemap
    if not spare_parts['child_department'].isna().all():
        fig = px.treemap(
            spare_parts,
            path=['child_department', 'name'],
            values='estimated_cost',
            title='üí∞ Inventory Value Distribution by Department',
            color='estimated_cost',
            color_continuous_scale='Viridis'
        )
    else:
        fig = px.treemap(
            spare_parts,
            path=['name'],
            values='estimated_cost',
            title='üí∞ Inventory Value Distribution',
            color='estimated_cost',
            color_continuous_scale='Viridis'
        )
    
    fig.update_layout(height=500)
    return fig

def create_value_distribution_chart(spare_parts):
    """Create value distribution analysis chart"""
    if spare_parts.empty:
        return create_empty_chart("No data for value distribution analysis")
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    spare_parts['estimated_value'] = spare_parts['quantity'] * spare_parts['min_order_level'] * 10
    
    # Handle department column
    if 'child_department' not in spare_parts.columns:
        if 'department_id' in spare_parts.columns:
            dept_mapping = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_info = st.session_state.data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_mapping[dept_id] = f'Dept_{dept_id}'
            spare_parts['child_department'] = spare_parts['department_id'].map(dept_mapping)
        else:
            spare_parts['child_department'] = 'General'
    
    # Fill any NaN values
    spare_parts['child_department'] = spare_parts['child_department'].fillna('Unknown')
    
    fig = px.box(
        spare_parts,
        x='child_department',
        y='estimated_value',
        title="üì¶ Value Distribution by Department",
        points='all'
    )
    
    fig.update_layout(height=500, xaxis_tickangle=-45)
    return fig

# =============================================================================
# ANALYTICAL CALCULATION FUNCTIONS
# =============================================================================

def calculate_inventory_value(spare_parts):
    """Calculate total inventory value (simplified)"""
    if spare_parts.empty:
        return 0
    
    spare_parts = spare_parts.copy()
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    return (spare_parts['quantity'] * spare_parts['min_order_level'] * 10).sum()

def calculate_stock_turnover_rate(transactions, spare_parts):
    """Calculate inventory turnover rate"""
    if transactions.empty or spare_parts.empty:
        return 0
    
    # Ensure numeric data types
    transactions = transactions.copy()
    spare_parts = spare_parts.copy()
    
    transactions['quantity'] = pd.to_numeric(transactions['quantity'], errors='coerce').fillna(0)
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    
    total_usage = abs(transactions[transactions['transaction_type'] == 'check_out']['quantity'].sum())
    avg_inventory = spare_parts['quantity'].mean()
    
    return total_usage / avg_inventory if avg_inventory != 0 else 0

def calculate_service_level(transactions):
    """Calculate service level percentage"""
    if transactions.empty:
        return 100
    
    total_demand = abs(transactions[transactions['transaction_type'] == 'check_out']['quantity'].sum())
    return 95.0  # Simplified - in real scenario, calculate based on stockouts

def calculate_abc_summary(spare_parts):
    """Calculate ABC analysis summary"""
    if spare_parts.empty:
        return pd.DataFrame()
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    # Simplified ABC calculation
    spare_parts['value_score'] = spare_parts['quantity'] * spare_parts['min_order_level']
    spare_parts = spare_parts.sort_values('value_score', ascending=False)
    spare_parts['cumulative_percentage'] = spare_parts['value_score'].cumsum() / spare_parts['value_score'].sum() * 100
    
    # Use explicit logic for ABC classification
    abc_class = []
    for cum_pct in spare_parts['cumulative_percentage']:
        if cum_pct <= 80:
            abc_class.append('A')
        elif cum_pct <= 95:
            abc_class.append('B')
        else:
            abc_class.append('C')
    
    spare_parts['abc_class'] = abc_class
    
    abc_summary = spare_parts.groupby('abc_class').agg({
        'name': 'count',
        'value_score': 'sum',
        'quantity': 'sum'
    }).rename(columns={'name': 'item_count', 'value_score': 'total_value'})
    
    abc_summary['percentage_items'] = (abc_summary['item_count'] / len(spare_parts)) * 100
    abc_summary['percentage_value'] = (abc_summary['total_value'] / spare_parts['value_score'].sum()) * 100
    
    return abc_summary.round(2)

def generate_stock_recommendations(spare_parts):
    """Generate stock level recommendations"""
    recommendations = []
    
    spare_parts = spare_parts.copy()
    
    # Ensure numeric columns
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    spare_parts['min_order_quantity'] = pd.to_numeric(spare_parts['min_order_quantity'], errors='coerce').fillna(1)
    
    # Last piece items
    last_piece = spare_parts[spare_parts['quantity'] == 1]
    if not last_piece.empty:
        recommendations.append({
            'type': 'üö® Immediate Reorder Required',
            'count': len(last_piece),
            'description': 'Items at last piece level require immediate attention to avoid stockouts.',
            'items': last_piece.assign(recommended_action='Immediate Reorder')
        })
    
    # Low stock items
    low_stock = spare_parts[
        (spare_parts['quantity'] > 1) & 
        (spare_parts['quantity'] <= spare_parts['min_order_level'])
    ]
    if not low_stock.empty:
        recommendations.append({
            'type': '‚ö†Ô∏è Low Stock Alert',
            'count': len(low_stock),
            'description': 'Items below minimum order level should be reordered soon.',
            'items': low_stock.assign(recommended_action='Schedule Reorder')
        })
    
    # Excess stock items
    excess_stock = spare_parts[spare_parts['quantity'] > spare_parts['min_order_level'] * 3]
    if not excess_stock.empty:
        recommendations.append({
            'type': 'üí° Excess Stock Identified',
            'count': len(excess_stock),
            'description': 'Items with stock levels significantly above requirements.',
            'items': excess_stock.assign(recommended_action='Review Stock Levels')
        })
    
    return recommendations

def generate_cost_recommendations(spare_parts, transactions):
    """Generate cost optimization recommendations"""
    recommendations = []
    
    # EOQ recommendation
    recommendations.append({
        'title': 'Implement Economic Order Quantity',
        'savings': 15000,
        'description': 'Optimize order quantities to balance ordering and holding costs.',
        'implementation': 'Medium term (1-2 months)'
    })
    
    # ABC analysis implementation
    recommendations.append({
        'title': 'ABC Analysis Based Management',
        'savings': 8000,
        'description': 'Focus management efforts on high-value A items for maximum impact.',
        'implementation': 'Short term (2-4 weeks)'
    })
    
    # Safety stock optimization
    recommendations.append({
        'title': 'Safety Stock Optimization',
        'savings': 5000,
        'description': 'Adjust safety stock levels based on demand variability and lead times.',
        'implementation': 'Medium term (1-3 months)'
    })
    
    return recommendations

# =============================================================================
# REPORT GENERATION FUNCTIONS
# =============================================================================

def generate_inventory_performance_report(days, department_id, user_role):
    """Generate comprehensive inventory performance report"""
    st.subheader("Inventory Performance Report")
    
    # Get data based on user role and department
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
            transactions = st.session_state.data_manager.get_transaction_history_by_department(department_id, days)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
            transactions = st.session_state.data_manager.get_transaction_history(days=days)
    
    # Ensure data consistency
    spare_parts = ensure_data_consistency(spare_parts)
    transactions = ensure_data_consistency(transactions)
    
    if transactions.empty or spare_parts.empty:
        st.warning("Insufficient data for performance report")
        return
    
    # Performance metrics
    col1, col2 = st.columns(2)
    
    with col1:
        st.metric("Total Items", len(spare_parts))
        st.metric("Total Transactions", len(transactions))
        st.metric("Average Daily Movement", f"{len(transactions)/max(days, 1):.1f}")
    
    with col2:
        st.metric("Stock Accuracy", "98.2%")
        st.metric("Order Cycle Time", "4.2 days")
        st.metric("Inventory Accuracy", "99.1%")
    
    # Detailed analysis
    st.subheader("Detailed Analysis")
    
    analysis_col1, analysis_col2 = st.columns(2)
    
    with analysis_col1:
        st.write("**Top 10 Moving Items**")
        top_movers = transactions.groupby('name')['quantity'].sum().abs().nlargest(10)
        st.dataframe(top_movers, use_container_width=True)
    
    with analysis_col2:
        st.write("**Department Performance**")
        
        # Fix: Handle department information properly
        dept_perf = transactions.copy()
        
        # Check if child_department exists in transactions, if not try to merge
        if 'child_department' not in dept_perf.columns and 'part_id' in dept_perf.columns:
            # Merge with spare_parts to get department information
            if 'id' in spare_parts.columns and 'child_department' in spare_parts.columns:
                dept_perf = dept_perf.merge(
                    spare_parts[['id', 'child_department']], 
                    left_on='part_id', 
                    right_on='id', 
                    how='left'
                )
        
        # If we still don't have child_department, try to get it from department_id
        if 'child_department' not in dept_perf.columns and 'department_id' in spare_parts.columns:
            # Create department mapping
            dept_mapping = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_info = st.session_state.data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_mapping[dept_id] = f'Dept_{dept_id}'
            
            # Merge department mapping
            if 'department_id' in dept_perf.columns:
                dept_perf['child_department'] = dept_perf['department_id'].map(dept_mapping)
            elif 'part_id' in dept_perf.columns:
                # Create part_id to department_id mapping
                part_dept_mapping = spare_parts.set_index('id')['department_id'].to_dict()
                dept_perf['department_id'] = dept_perf['part_id'].map(part_dept_mapping)
                dept_perf['child_department'] = dept_perf['department_id'].map(dept_mapping)
        
        # If we still don't have department info, use a default
        if 'child_department' not in dept_perf.columns:
            dept_perf['child_department'] = 'General Department'
        
        # Fill any NaN values
        dept_perf['child_department'] = dept_perf['child_department'].fillna('Unknown Department')
        
        # Now group by department
        if 'child_department' in dept_perf.columns:
            dept_summary = dept_perf.groupby('child_department').size().nlargest(5)
            st.dataframe(dept_summary, use_container_width=True)
        else:
            st.info("No department information available")

def generate_stock_optimization_report(days, department_id, user_role):
    """Generate stock optimization report"""
    st.subheader("Stock Optimization Report")
    
    # Get data based on user role and department
    if user_role == 'User':
        spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
    else:
        if department_id:
            spare_parts = st.session_state.data_manager.get_parts_by_department(department_id)
        else:
            spare_parts = st.session_state.data_manager.get_all_parts()
    
    # Ensure data consistency
    spare_parts = ensure_data_consistency(spare_parts)
    
    if spare_parts.empty:
        st.warning("No data for stock optimization report")
        return
    
    # Stock optimization analysis
    st.write("**Current Stock Status**")
    
    status_col1, status_col2, status_col3 = st.columns(3)
    
    with status_col1:
        healthy_stock = len(spare_parts[spare_parts['quantity'] > spare_parts['min_order_level']])
        st.metric("Healthy Stock Items", healthy_stock)
    
    with status_col2:
        low_stock = len(spare_parts[
            (spare_parts['quantity'] <= spare_parts['min_order_level']) & 
            (spare_parts['quantity'] > 1)
        ])
        st.metric("Low Stock Items", low_stock)
    
    with status_col3:
        last_piece = len(spare_parts[spare_parts['quantity'] == 1])
        st.metric("Last Piece Items", last_piece)
    
    # Optimization recommendations
    st.subheader("Optimization Recommendations")
    
    rec1, rec2, rec3 = st.columns(3)
    
    with rec1:
        st.info("**Reorder Point Adjustment**\n\nReview and adjust reorder points for 45 items based on recent demand patterns.")
    
    with rec2:
        st.info("**Safety Stock Optimization**\n\nOptimize safety stock levels for 23 high-variability items.")
    
    with rec3:
        st.info("**Excess Stock Reduction**\n\nIdentify opportunities to reduce excess stock for 15 overstocked items.")

def generate_demand_analysis_report(days, department_id, user_role):
    """Generate demand analysis report"""
    st.subheader("Demand Analysis Report - Placeholder")
    st.info("Detailed demand analysis report will be implemented here.")

def generate_cost_analysis_report(days, department_id, user_role):
    """Generate cost analysis report"""
    st.subheader("Cost Analysis Report - Placeholder")
    st.info("Detailed cost analysis report will be implemented here.")

def generate_department_performance_report(days, department_id, user_role):
    """Generate department performance report"""
    st.subheader("Department Performance Report - Placeholder")
    st.info("Detailed department performance report will be implemented here.")

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def create_empty_chart(message):
    """Create an empty chart with a message"""
    fig = go.Figure()
    fig.add_annotation(
        text=message,
        xref="paper", yref="paper",
        x=0.5, y=0.5,
        showarrow=False,
        font=dict(size=16)
    )
    fig.update_layout(height=400)
    return fig

def ensure_data_consistency(df, expected_columns=None):
    """Ensure dataframe has expected columns and proper data types"""
    if df.empty:
        return df
    
    df = df.copy()
    
    # Ensure numeric columns are properly typed
    numeric_columns = ['quantity', 'min_order_level', 'min_order_quantity', 'line_no']
    for col in numeric_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
    
    # Handle department information
    if 'child_department' not in df.columns and 'department_id' in df.columns:
        # Create department mapping
        dept_mapping = {}
        for dept_id in df['department_id'].unique():
            dept_info = st.session_state.data_manager.get_department_info(dept_id)
            if dept_info is not None and not dept_info.empty:
                dept_mapping[dept_id] = dept_info.get('child_department', f'Dept_{dept_id}')
            else:
                dept_mapping[dept_id] = f'Dept_{dept_id}'
        df['child_department'] = df['department_id'].map(dept_mapping)
    elif 'child_department' not in df.columns:
        df['child_department'] = 'General Department'
    
    # Fill any NaN values in critical columns
    if 'child_department' in df.columns:
        df['child_department'] = df['child_department'].fillna('Unknown Department')
    
    return df

def calculate_value_change(transactions):
    """Calculate inventory value change (simplified)"""
    return 2500  # Placeholder

def calculate_turnover_trend(transactions):
    """Calculate turnover trend (simplified)"""
    return 0.3  # Placeholder

def calculate_excess_stock_value(spare_parts):
    """Calculate excess stock value (simplified)"""
    if spare_parts.empty:
        return 0
    excess = spare_parts[spare_parts['quantity'] > spare_parts['min_order_level'] * 2]
    return (excess['quantity'] * 50).sum()  # Placeholder calculation

def calculate_stockout_risk(spare_parts):
    """Calculate stockout risk items count"""
    if spare_parts.empty:
        return 0
    return len(spare_parts[spare_parts['quantity'] <= spare_parts['min_order_level']])

def calculate_optimal_stock_level(spare_parts):
    """Calculate optimal stock level achievement"""
    if spare_parts.empty:
        return 0
    optimal = spare_parts[spare_parts['quantity'] > spare_parts['min_order_level']]
    return (len(optimal) / len(spare_parts)) * 100

def create_reorder_analysis_chart(spare_parts, transactions):
    """Create reorder analysis chart"""
    return create_empty_chart("Reorder analysis chart placeholder")

def calculate_average_daily_demand(transactions):
    """Calculate average daily demand"""
    if transactions.empty:
        return 0
    transactions['date'] = pd.to_datetime(transactions['timestamp']).dt.date
    daily_demand = transactions.groupby('date')['quantity'].sum()
    return daily_demand.mean()

def calculate_demand_variability(transactions):
    """Calculate demand variability coefficient"""
    if transactions.empty:
        return 0
    transactions['date'] = pd.to_datetime(transactions['timestamp']).dt.date
    daily_demand = transactions.groupby('date')['quantity'].sum()
    return daily_demand.std() / daily_demand.mean() if daily_demand.mean() != 0 else 0

def identify_peak_demand(transactions):
    """Identify peak demand period"""
    if transactions.empty:
        return "N/A"
    transactions['hour'] = pd.to_datetime(transactions['timestamp']).dt.hour
    hourly_demand = transactions.groupby('hour')['quantity'].sum()
    return f"{hourly_demand.idxmax()}:00"

def detect_seasonal_trend(transactions):
    """Detect seasonal trend (simplified)"""
    return "Stable"

def create_weekly_demand_pattern(transactions):
    """Create weekly demand pattern chart"""
    return create_empty_chart("Weekly demand pattern chart placeholder")

def create_demand_correlation_heatmap(transactions):
    """Create demand correlation heatmap"""
    return create_empty_chart("Demand correlation heatmap placeholder")

def calculate_carrying_cost(spare_parts):
    """Calculate carrying cost (simplified)"""
    if spare_parts.empty:
        return 0
    return (calculate_inventory_value(spare_parts) * 0.25)  # 25% carrying cost

def estimate_stockout_cost(transactions, spare_parts):
    """Estimate stockout cost (simplified)"""
    return 5000  # Placeholder

def calculate_eoq_savings(spare_parts):
    """Calculate EOQ potential savings (simplified)"""
    return 12000  # Placeholder

if __name__ == "__main__":
    render_analytics_page()
</file>

<file path="main.py">
import streamlit as st
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from user_management import login_required, init_session_state, render_login_page
from navbar import make_sidebar
from app_settings import set_page_configuration
from datetime import datetime, timedelta
import pandas as pd
from session_manager import session_manager

set_page_configuration()

def check_persistent_session():
    """Check for and restore persistent session"""
    init_session_state()
    
    # If already authenticated, do nothing
    if st.session_state.get('authenticated', False):
        return True
    
    # Try to restore from cookie
    session_data = session_manager.get_session_cookie()
    if session_data and session_manager.verify_session(session_data):
        # Restore session
        st.session_state.authenticated = True
        st.session_state.username = session_data.get('username')
        st.session_state.user_role = session_data.get('user_role')
        st.session_state.user_id = session_data.get('user_id')
        st.session_state.user_department_id = session_data.get('user_department_id')
        st.session_state.login_time = datetime.fromisoformat(session_data.get('login_time'))
        st.session_state.session_id = session_data.get('session_id')
        return True
    
    return False

# Initialize session state on app start
init_session_state()

# Initialize alerts in session state
if 'alerts' not in st.session_state:
    st.session_state.alerts = []


@login_required
def main():
    # Check for persistent session first
    has_valid_session = check_persistent_session()
    
    # If not authenticated and no valid session, show login page
    if not has_valid_session and not st.session_state.get('authenticated', False):
        render_login_page()
        return

    st.title("Ship Inventory Management System")

    # Show user info in sidebar
    with st.sidebar:
        make_sidebar()

    # Dashboard layout
    col1, col2, col3 = st.columns(3)

    with col1:
        lpl_stock = st.session_state.data_manager.get_last_piece_stock_items()
        low_stock = st.session_state.data_manager.get_low_stock_items()
        df = st.session_state.data_manager.get_all_parts()
        total_parts = len(df)
        low_stock_count = len(low_stock)
        lpl_stock_count = len(lpl_stock)

        st.metric("Total Parts",
                  total_parts,
                  help="Total number of unique parts in inventory")
 
    with col2:
        st.metric("LPL Stock Items",
                  lpl_stock_count,
                  delta=lpl_stock_count,
                  delta_color="inverse",
                  help="Number of items below last piece level")
        
    with col3:
        active_alerts = len(low_stock) + len(lpl_stock)
        monthly_turnover = calculate_monthly_turnover()
        st.metric("Active Alerts", active_alerts, delta=active_alerts, delta_color="inverse")

    # Quick Insights Section
    st.subheader("üìä Quick Insights")
    
    insight_col1, insight_col2 = st.columns(2)
    
    with insight_col1:
        # Top moving items
        st.write("**üöÄ Fast Moving Items**")
        fast_moving = get_fast_moving_items()
        if not fast_moving.empty:
            for _, item in fast_moving.head(3).iterrows():
                st.write(f"‚Ä¢ {item['name']} - {item['transaction_count']} moves")
        else:
            st.write("‚Ä¢ No fast moving items data")
        
        # Maintenance schedule
        st.write("**üîß Upcoming Maintenance**")
        maintenance_due = get_maintenance_due()
        if not maintenance_due.empty:
            for _, item in maintenance_due.head(3).iterrows():
                days_until = (item['next_maintenance_date'] - datetime.now().date()).days
                st.write(f"‚Ä¢ {item['name']} - {days_until} days")
        else:
            st.write("‚Ä¢ No maintenance scheduled")
    
    with insight_col2:
        # Department overview
        st.write("**üèóÔ∏è Department Overview**")
        dept_summary = get_department_summary()
        
        # Fix: Handle dictionary properly - dictionaries don't have .empty attribute
        if dept_summary and isinstance(dept_summary, dict):
            # Convert to list of items and take first 4
            dept_items = list(dept_summary.items())[:4]
            for dept, count in dept_items:
                st.write(f"‚Ä¢ {dept}: {count} items")
        elif isinstance(dept_summary, pd.DataFrame) and not dept_summary.empty:
            # Handle DataFrame case
            for dept, count in dept_summary.head(4).items():
                st.write(f"‚Ä¢ {dept}: {count} items")
        else:
            st.write("‚Ä¢ No department data available")
        
        # Recent critical events
        st.write("**‚ö†Ô∏è Recent Critical Events**")
        critical_events = get_critical_events()
        if critical_events:
            for event in critical_events[:3]:  # Show only first 3 events
                st.write(f"‚Ä¢ {event}")
        else:
            st.write("‚Ä¢ No critical events")

    # Quick Actions
    st.subheader("üöÄ Quick Actions")
    action_col1, action_col2 = st.columns(2)
    
    with action_col1:
        if st.button("View Last Piece Level Stock Alerts"):
            lpl_stock = st.session_state.data_manager.get_last_piece_stock_items()
            if not lpl_stock.empty:
                st.dataframe(lpl_stock[[
                    'name', 'part_number', 'quantity', 'min_order_level'
                ]],
                             hide_index=True)

                # Download low stock report
                csv = lpl_stock.to_csv(index=False)
                st.download_button(
                    "Download Last Piece Level Stock Report",
                    csv,
                    "last_piece_stock_report.csv",
                    "text/csv",
                    help="Download a CSV report of all last piece level stock items")
            else:
                st.success("All items are above last piece levels")

    with action_col2:
        if st.button("View Low Stock Items"):
            low_stock = st.session_state.data_manager.get_low_stock_items()
            if not low_stock.empty:
                st.dataframe(low_stock[[
                    'name', 'part_number', 'quantity', 'min_order_level'
                ]],
                             hide_index=True)

                # Download low stock report
                csv = low_stock.to_csv(index=False)
                st.download_button(
                    "Download Low Stock Report",
                    csv,
                    "low_stock_report.csv",
                    "text/csv",
                    help="Download a CSV report of all low stock items")
            else:
                st.success("All items are above minimum stock levels")

    # Recent Transactions
    st.subheader("Recent Transactions")
    
    # Enhanced Recent Transactions with filters
    trans_col1, trans_col2 = st.columns(2)
    with trans_col1:
        trans_days = st.selectbox("Time Period", [7, 30, 90], index=0, key="trans_days")
    with trans_col2:
        trans_type = st.selectbox("Transaction Type", ["All", "Check-Out", "Check-In"], key="trans_type")
    
    recent_transactions = st.session_state.data_manager.get_transaction_history(days=30)
    filtered_transactions = filter_transactions(recent_transactions, trans_days, trans_type)
    
    if not filtered_transactions.empty:
        st.dataframe(filtered_transactions[[
            'timestamp', 'name', 'transaction_type', 'quantity'
        ]],
                     hide_index=True)
        
        # Transaction summary
        summary_col1, summary_col2, summary_col3 = st.columns(3)
        with summary_col1:
            check_outs = len(filtered_transactions[filtered_transactions['transaction_type'] == 'check_out'])
            st.metric("Check-Outs", check_outs)
        with summary_col2:
            check_ins = len(filtered_transactions[filtered_transactions['transaction_type'] == 'check_in'])
            st.metric("Check-Ins", check_ins)
        with summary_col3:
            total_movement = abs(filtered_transactions['quantity'].sum())
            st.metric("Total Movement", total_movement)
    else:
        st.info("No recent transactions found")

# Helper functions
def calculate_inventory_value(spare_parts):
    """Calculate total inventory value (simplified)"""
    if spare_parts.empty:
        return 0
    
    spare_parts = spare_parts.copy()
    spare_parts['quantity'] = pd.to_numeric(spare_parts['quantity'], errors='coerce').fillna(0)
    spare_parts['min_order_level'] = pd.to_numeric(spare_parts['min_order_level'], errors='coerce').fillna(0)
    
    return (spare_parts['quantity'] * spare_parts['min_order_level'] * 10).sum()

def calculate_monthly_turnover():
    """Calculate monthly inventory turnover rate"""
    try:
        # This would need to be implemented based on your business logic
        return 15  # Placeholder
    except:
        return 0

def get_fast_moving_items():
    """Get items with highest transaction frequency"""
    try:
        data_manager = st.session_state.data_manager
        transactions = data_manager.get_transaction_history(days=30)
        
        if transactions.empty:
            return pd.DataFrame()
        
        # Group by item name and count transactions
        fast_moving = transactions.groupby('name').agg({
            'quantity': 'sum',
            'timestamp': 'count'
        }).rename(columns={'timestamp': 'transaction_count'})
        
        # Sort by transaction count
        fast_moving = fast_moving.sort_values('transaction_count', ascending=False)
        return fast_moving.reset_index()
        
    except Exception as e:
        print(f"Error in get_fast_moving_items: {e}")
        return pd.DataFrame()

def get_maintenance_due():
    """Get items due for maintenance soon"""
    try:
        data_manager = st.session_state.data_manager
        spare_parts = data_manager.get_all_parts()
        
        if spare_parts.empty:
            return pd.DataFrame()
        
        # Check for next_maintenance_date column
        if 'next_maintenance_date' not in spare_parts.columns:
            return pd.DataFrame()
        
        # Filter items with upcoming maintenance
        spare_parts = spare_parts.copy()
        spare_parts['next_maintenance_date'] = pd.to_datetime(spare_parts['next_maintenance_date'], errors='coerce')
        
        # Get items with maintenance due in next 30 days
        today = datetime.now().date()
        future_date = today + timedelta(days=30)
        
        maintenance_due = spare_parts[
            (spare_parts['next_maintenance_date'].notna()) &
            (spare_parts['next_maintenance_date'].dt.date >= today) &
            (spare_parts['next_maintenance_date'].dt.date <= future_date)
        ]
        
        return maintenance_due[['name', 'next_maintenance_date']].sort_values('next_maintenance_date')
        
    except Exception as e:
        print(f"Error in get_maintenance_due: {e}")
        return pd.DataFrame()

def get_department_summary():
    """Get item count by department"""
    try:
        data_manager = st.session_state.data_manager
        spare_parts = data_manager.get_all_parts()
        
        if spare_parts.empty:
            return {}
        
        # Ensure we have department information
        if 'child_department' in spare_parts.columns:
            dept_counts = spare_parts['child_department'].value_counts().to_dict()
        elif 'department_id' in spare_parts.columns:
            # Create department mapping
            dept_mapping = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_info = data_manager.get_department_info(dept_id)
                if dept_info is not None and not dept_info.empty:
                    dept_name = dept_info.get('child_department', f'Dept_{dept_id}')
                else:
                    dept_name = f'Dept_{dept_id}'
                dept_mapping[dept_id] = dept_name
            
            # Count items per department
            dept_counts = {}
            for dept_id in spare_parts['department_id'].unique():
                dept_name = dept_mapping.get(dept_id, f'Dept_{dept_id}')
                count = len(spare_parts[spare_parts['department_id'] == dept_id])
                dept_counts[dept_name] = count
        else:
            dept_counts = {'General': len(spare_parts)}
        
        return dept_counts
        
    except Exception as e:
        print(f"Error in get_department_summary: {e}")
        return {}

def get_critical_events():
    """Get recent critical stock events"""
    try:
        data_manager = st.session_state.data_manager
        
        # Get low stock and last piece items
        low_stock = data_manager.get_low_stock_items()
        last_piece = data_manager.get_last_piece_stock_items()
        
        critical_events = []
        
        # Add last piece alerts
        if not last_piece.empty:
            for _, item in last_piece.head(2).iterrows():  # Limit to 2 items
                critical_events.append(f"Last piece: {item['name']} (Only {item['quantity']} left)")
        
        # Add low stock alerts
        if not low_stock.empty:
            for _, item in low_stock.head(2).iterrows():  # Limit to 2 items
                critical_events.append(f"Low stock: {item['name']} ({item['quantity']} left, min: {item['min_order_level']})")
        
        # If no critical events, add a message
        if not critical_events:
            critical_events.append("No critical events - all systems normal")
        
        return critical_events
        
    except Exception as e:
        print(f"Error in get_critical_events: {e}")
        return ["Error loading critical events"]

def filter_transactions(transactions, days, trans_type):
    """Filter transactions based on criteria"""
    try:
        filtered = transactions.copy()
        
        # Filter by date
        if days > 0:
            cutoff_date = datetime.now() - timedelta(days=days)
            filtered['timestamp'] = pd.to_datetime(filtered['timestamp'])
            filtered = filtered[filtered['timestamp'] >= cutoff_date]
        
        # Filter by transaction type
        if trans_type != "All":
            trans_type_map = {"Check-Out": "check_out", "Check-In": "check_in"}
            if trans_type in trans_type_map:
                filtered = filtered[filtered['transaction_type'] == trans_type_map[trans_type]]
        
        return filtered
        
    except Exception as e:
        print(f"Error in filter_transactions: {e}")
        return pd.DataFrame()

# Only run the main function if this is the main script
if __name__ == "__main__":
    main()
</file>

<file path="navbar.py">
import streamlit as st
from time import sleep
from streamlit_option_menu import option_menu
from user_management import init_session_state, render_login_page, check_session
import base64
from data_manager import DataManager
from session_manager import session_manager

# Define the pages and their file paths
pages = {
    'Home': 'main.py',
    'User Management': 'pages/admin.py',
    'Departments': 'pages/departments.py',
    'Data Management': 'pages/data_management.py',  # Add this line
    'Analytics': 'pages/analytics.py',
    'Inventory': 'pages/inventory.py',
    'Operations': 'pages/operations.py',
    'Reports': 'pages/reports.py',
    'Logout': 'main.py'
}

icons = [
    'house', 'people-fill', 'building', 'database', 'graph-up-arrow', 'gear', 'toggles',
    'clipboard2-data', 'box-arrow-right'
]

# Create a list of the page names
page_list = list(pages.keys())


def nav(current_page=page_list[0]):
    """Navigation sidebar with persistent session handling"""
    # Initialize session state first
    init_session_state()

    with st.sidebar:
        #st.image("logo.png", width=100)
        add_logo()
        st.write("")

        if st.session_state.authenticated:
             # Safe session state access
            username = st.session_state.get('username', 'Guest')
            user_role = st.session_state.get('user_role', '')
            
            st.write(f"Logged in as: {username}")
            st.write(f"Role: {user_role}")

            # Determine visible pages based on user role
            user_role = st.session_state.get('user_role', 'user')
            #print("user_role:", user_role)  # Add this temporarily
            if user_role == 'Super User':
                visible_pages = list(pages.keys())
                visible_icons = icons
            elif user_role == 'Admin':
                # Exclude User Management and Departments
                visible_pages = [p for p in pages.keys() 
                            if p not in ['User Management', 'Departments', 'Data Management']]
                visible_icons = [icon for icon, p in zip(icons, pages.keys())
                            if p not in ['User Management', 'Departments', 'Data Management']]
            elif user_role == 'User':
                visible_pages = ['Inventory', 'Reports', 'Logout']
                visible_icons = ['gear', 'clipboard2-data', 'box-arrow-right']
            else:
                visible_pages = []
                visible_icons = []


            #print("visible_pages list 2:", visible_pages)  # Add this temporarily
            # Create the menu
            if visible_pages:
                selected = option_menu(
                    "Menu",
                    visible_pages,
                    icons=visible_icons,
                    default_index=visible_pages.index(current_page) if current_page in visible_pages else 0,
                    orientation="vertical"
                )
                
                 # Handle logout
                if selected == "Logout":
                    logout()
                    return

                if current_page != selected:
                    st.switch_page(pages[selected])
            
            # Safely check for low stock items
            if 'data_manager' in st.session_state:
                try:
                    # Alert Section in Sidebar
                    if st.session_state.user_role == 'User':
                        lpl_stock = st.session_state.data_manager.get_last_piece_stock_items_by_dept(st.session_state.get('user_department_id'))
                    else:
                        lpl_stock = st.session_state.data_manager.get_last_piece_stock_items()
                    if not lpl_stock.empty:
                        st.error(
                            f"üö® {len(lpl_stock)} - Last Piece Level!")
                        with st.expander("View Last Piece Level Stock Alerts"):
                            for _, item in lpl_stock.iterrows():
                                st.warning(f"""
                                    **{item['name']}**
                                    - Current: {item['quantity']}
                                    - Minimum: {item['min_order_level']}
                                    - Order Quantity: {item['min_order_quantity']}
                                """)

                    if st.session_state.user_role == 'User':
                        low_stock = st.session_state.data_manager.get_low_stock_items_by_dept(st.session_state.get('user_department_id'))
                    else:
                        low_stock = st.session_state.data_manager.get_low_stock_items()
                    if not low_stock.empty:
                        st.error(
                            f"üö® {len(low_stock)} items below minimum stock level!")
                        with st.expander("View Low Stock Alerts"):
                            for _, item in low_stock.iterrows():
                                st.warning(f"""
                                    **{item['name']}**
                                    - Current: {item['quantity']}
                                    - Minimum: {item['min_order_level']}
                                    - Order Quantity: {item['min_order_quantity']}
                                """)
                except Exception as e:
                    st.error(f"Error checking stock levels: {str(e)}")

        
        else:
            # Show login page without sidebar navigation
            st.info("Please log in to access the system")
            # Don't render login page here to avoid duplication

def make_sidebar(current_page=page_list[0]):
    """Alternative sidebar function for main page"""
    nav(current_page)

def make_sidebar_old(current_page=page_list[0]):
    # Initialize selected variable
    selected = None

    # Initialize session state if not already done
    if 'authenticated' not in st.session_state:
        init_session_state()

    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()

    with st.sidebar:
        #st.image("logo.png", width=100)
        add_logo()
        st.write("")
        #print("visible_pages list:")  # Add this temporarily
        if st.session_state.authenticated:
            st.write(f"Logged in as: {st.session_state.username}")
            st.write(f"Role: {st.session_state.user_role}")
            #print("Page list:", page_list)  # Add this temporarily
            
            

            user_role = st.session_state.get('user_role', 'user')
            #print("user_role:", user_role)  # Add this temporarily
            if user_role == 'Super User':
                visible_pages = list(pages.keys())
                visible_icons = icons
            elif user_role == 'Admin':
                # Exclude User Management and Departments
                visible_pages = [p for p in pages.keys() 
                            if p not in ['User Management', 'Departments', 'Data Management']]
                visible_icons = [icon for icon, p in zip(icons, pages.keys())
                            if p not in ['User Management', 'Departments', 'Data Management']]
            elif user_role == 'User':
                visible_pages = ['Inventory', 'Reports', 'Logout']
                visible_icons = ['gear', 'clipboard2-data', 'box-arrow-right']
            else:
                visible_pages = []
                visible_icons = []


            #print("visible_pages list 2:", visible_pages)  # Add this temporarily
            # Create the menu
            if visible_pages:
                selected = option_menu(
                    "Menu",
                    visible_pages,
                    icons=visible_icons,
                    default_index=visible_pages.index(current_page) if current_page in visible_pages else 0,
                    orientation="vertical"
                )
                
                # Handle logout
                if selected == "Logout":
                    #st.session_state.clear()  # Clear all session state
                    # Clear session state
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()   # Rerun to show login page

                if current_page != selected:
                    st.switch_page(pages[selected])
            
            # Safely check for low stock items
            if 'data_manager' in st.session_state:
                try:
                    # Alert Section in Sidebar
                    if st.session_state.user_role == 'User':
                        lpl_stock = st.session_state.data_manager.get_last_piece_stock_items_by_dept(st.session_state.get('user_department_id'))
                    else:
                        lpl_stock = st.session_state.data_manager.get_last_piece_stock_items()
                    if not lpl_stock.empty:
                        st.error(
                            f"üö® {len(lpl_stock)} - Last Piece Level!")
                        with st.expander("View Last Piece Level Stock Alerts"):
                            for _, item in lpl_stock.iterrows():
                                st.warning(f"""
                                    **{item['name']}**
                                    - Current: {item['quantity']}
                                    - Minimum: {item['min_order_level']}
                                    - Order Quantity: {item['min_order_quantity']}
                                """)
                                
                    if st.session_state.user_role == 'User':
                        low_stock = st.session_state.data_manager.get_low_stock_items_by_dept(st.session_state.get('user_department_id'))
                    else:
                        low_stock = st.session_state.data_manager.get_low_stock_items()
                    if not low_stock.empty:
                        st.error(
                            f"üö® {len(low_stock)} items below minimum stock level!")
                        with st.expander("View Low Stock Alerts"):
                            for _, item in low_stock.iterrows():
                                st.warning(f"""
                                    **{item['name']}**
                                    - Current: {item['quantity']}
                                    - Minimum: {item['min_order_level']}
                                    - Order Quantity: {item['min_order_quantity']}
                                """)
                except Exception as e:
                    st.error(f"Error checking stock levels: {str(e)}")
                    
        else:
            # Show login page without sidebar
            st.set_page_config(layout="centered")
            render_login_page()

            

        #elif current_page != p:
        # If anyone tries to access a secret page without being logged in,
        # redirect them to the login page
        #st.switch_page("login.py")
        #   render_login_page()


def logout():
    """Proper logout function that clears all session data"""
    # Clear session cookie
    session_manager.clear_session_cookie()
    
    # Clear all session state
    for key in list(st.session_state.keys()):
        del st.session_state[key]
    
    st.info("Logged out successfully!")
    st.rerun()

def get_base64_of_bin_file(png_file: str) -> str:
    with open(png_file, "rb") as f:
        return base64.b64encode(f.read()).decode()

@st.cache_resource
def build_markup_for_logo(png_file: str) -> str:
    binary_string = get_base64_of_bin_file(png_file)
    return f"""
            <style>
                [data-testid="stSidebarHeader"] {{
                    background-image: url("data:image/png;base64,{binary_string}");
                    background-repeat: no-repeat;
                    background-size: contain;
                    background-position: top center;
                }}
            </style>
            """

def add_logo():
    st.markdown(
        build_markup_for_logo("logo.png"),
        unsafe_allow_html=True,
    )

#st.switch_page("login.py")
</file>

<file path="pages/inventory.py">
import streamlit as st
import pandas as pd  # Add this import at the top
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from user_management import login_required, init_session_state
import navbar
from datetime import datetime
from app_settings import set_page_configuration
import time

set_page_configuration()

current_page = "Inventory"
st.header(current_page)

# Initialize session state
init_session_state()

navbar.nav(current_page)

@login_required
def render_inventory_page():

    # Initialize session state if needed
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    if 'barcode_handler' not in st.session_state:
        st.session_state.barcode_handler = BarcodeHandler()
             
    # Initialize session state for department selection
    if 'selected_parent_dept' not in st.session_state:
        st.session_state.selected_parent_dept = None
    if 'selected_child_dept' not in st.session_state:
        st.session_state.selected_child_dept = None

    # Get current user's department from session state
    current_user_dept_id = st.session_state.get('user_department_id')
    
    # Create tabs - CORRECTED VERSION
    if st.session_state.user_role == 'User':
        tabs = st.tabs(["View Inventory"])
        view_tab = tabs[0]  # Get the first (and only) tab
    else:
        tabs = st.tabs(["View Inventory", "Add New Part", "Bulk Import"])
        view_tab, add_tab, bulk_tab = tabs  # Properly unpack the tabs

    with view_tab:        
        if st.session_state.user_role == 'User':
            # For regular users, only show items from their department
            if not current_user_dept_id:
                st.error("You are not assigned to any department. Please contact administrator.")
                return
            #print("dept_id:", current_user_dept_id)  # Add this temporarily
            # Show department info
            dept_info = st.session_state.data_manager.get_department_info(current_user_dept_id)
            #print("dept_info:", dept_info)  # Add this temporarily
            if dept_info is not None and not dept_info.empty:
                st.subheader(f"Inventory for {dept_info['child_department']} Department")
            
            # Get items only for user's department
            df = st.session_state.data_manager.get_parts_by_department(current_user_dept_id)

            # Search and filter 
            search_term = st.text_input("Search parts by name, description, part_number, box_no, compartment_no, ilms_code or barcode")
            if search_term:
                df = df[df['name'].str.contains(search_term, case=False) |
                        df['description'].str.contains(search_term, case=False) |
                        df['part_number'].str.contains(search_term, case=False) |
                        df['barcode'].str.contains(search_term, case=False) |
                        df['ilms_code'].str.contains(search_term, case=False) |
                        df['compartment_no'].str.contains(search_term, case=False) |
                        df['box_no'].str.contains(search_term, case=False)]

            if not df.empty:
                st.dataframe(df[[
                    'part_number', 'name', 'quantity', 'parent_department', 'child_department', 
                    'line_no', 'description', 'page_no', 'order_no',
                    'material_code', 'ilms_code', 'item_denomination',
                    'mustered', 'compartment_no', 'box_no', 'remark',
                    'min_order_level', 'barcode',
                    'status', 'last_maintenance_date',
                    'next_maintenance_date'
                ]],
                column_config={
                    "mustered": st.column_config.CheckboxColumn("Mustered"),
                    "quantity": st.column_config.NumberColumn("Qty", format="%d")
                },
                use_container_width=True,
                hide_index=True)
            else:
                st.info("""
                üì± Stock information not available for selected department.
                """)
        else:
            selected_child = ""
            cols = st.columns(2)

            with cols[0]:
                # Department selection
                parent_depts = st.session_state.data_manager.get_parent_departments()
                if parent_depts.empty:
                    st.error("No departments found. Please create departments first.")
                    return
                
                selected_parent = st.selectbox(
                    "Select Parent Department*",
                    parent_depts['id'].tolist(),
                    index=None,
                    placeholder="Select Parent Department",
                    format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                    key = "ListParentDept"
                )
            
            with cols[1]:
                child_depts = st.session_state.data_manager.get_child_departments(selected_parent)
                if not child_depts.empty:                                
                    selected_child = st.selectbox(
                        "Select Child Department*",
                        child_depts['id'].tolist(),
                        index=None,
                        placeholder="Select Child Department",
                        format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                        key = "ListChildDept"
                    )

            if selected_child is not None:
                df = st.session_state.data_manager.get_parts_by_department(selected_child)

                # Search and filter 
                search_term = st.text_input("Search parts by name, description, part_number, box_no, compartment_no, ilms_code or barcode")
                if search_term:
                    df = df[df['name'].str.contains(search_term, case=False) |
                            df['description'].str.contains(search_term, case=False) |
                            df['part_number'].str.contains(search_term, case=False) |
                            df['barcode'].str.contains(search_term, case=False) |
                            df['ilms_code'].str.contains(search_term, case=False) |
                            df['compartment_no'].str.contains(search_term, case=False) |
                            df['box_no'].str.contains(search_term, case=False)]

                if not df.empty:
                    st.dataframe(df[[
                        'part_number', 'name', 'quantity', 'parent_department', 'child_department', 
                        'line_no', 'description', 'page_no', 'order_no',
                        'material_code', 'ilms_code', 'item_denomination',
                        'mustered', 'compartment_no', 'box_no', 'remark',
                        'min_order_level', 'barcode',
                        'status', 'last_maintenance_date',
                        'next_maintenance_date'
                    ]],
                    column_config={
                        "mustered": st.column_config.CheckboxColumn("Mustered"),
                        "quantity": st.column_config.NumberColumn("Qty", format="%d")
                    },
                    use_container_width=True,
                    hide_index=True)
                else:
                    st.info("""
                    üì± Stock information not available for selected department.
                    """)

                if st.session_state.user_role in ['Admin', 'Super User']:
                    # Edit part
                    if not df.empty:
                        part_to_edit = st.selectbox("Select part to edit",
                                                    df['description'].tolist())
                        
                        # Define available status options
                        status_options = ["In Store", "Operational", "Under Maintenance"]
                        
                        if part_to_edit:
                            part_data = df[df['description'] == part_to_edit].iloc[0]
                            # Get current status (handle empty/NaN values)
                            current_status = str(part_data['status']).strip() if pd.notna(part_data['status']) else None
                            try:
                                # Handle empty/None values first
                                if pd.isna(part_data['last_maintenance_date']) or not part_data['last_maintenance_date']:
                                    last_default_date = None
                                else:
                                    # Convert to string and parse date
                                    date_str = str(part_data['last_maintenance_date']).strip()
                                    last_default_date = datetime.strptime(date_str, '%Y-%m-%d').date()
                            except (ValueError, TypeError) as e:
                                #st.warning(f"Could not parse date: {part_data['last_maintenance_date']}. Error: {str(e)}")
                                last_default_date = None

                            try:
                                # Handle empty/None values first
                                if pd.isna(part_data['next_maintenance_date']) or not part_data['next_maintenance_date']:
                                    next_default_date = None
                                else:
                                    # Convert to string and parse date
                                    date_str = str(part_data['next_maintenance_date']).strip()
                                    next_default_date = datetime.strptime(date_str, '%Y-%m-%d').date()
                            except (ValueError, TypeError) as e:
                                #st.warning(f"Could not parse date: {part_data['last_maintenance_date']}. Error: {str(e)}")
                                next_default_date = None

                            with st.form("edit_part_form"):
                                new_quantity = st.number_input("Quantity",
                                                            value=int(
                                                                part_data['quantity']),
                                                            min_value=0)
                                new_min_level = st.number_input(
                                    "Minimum Order Level",
                                    value=int(part_data['min_order_level']),
                                    min_value=0)
                                new_min_quantity = st.number_input(
                                    "Minimum Order Quantity",
                                    value=int(part_data['min_order_quantity']),
                                    min_value=1)                    
                                new_status = st.selectbox(
                                    "Status*",
                                    options=status_options,
                                    index=None if current_status not in status_options else status_options.index(current_status),
                                    placeholder="Select a status...",
                                    key=f"status_select_{part_data['id']}"
                                )
                                new_last_maintenance_date = st.date_input(
                                    "Last Maintenance Date (optional)",
                                    value=last_default_date,
                                    key=f"last_maint_{part_data['id']}"
                                )
                                new_next_maintenance_date = st.date_input(
                                    "Next Maintenance Date (optional)",
                                    value=next_default_date,
                                    key=f"next_maint_{part_data['id']}"
                                )

                                # Convert back to string for database
                                if new_last_maintenance_date:
                                    nlast_maint_date_str = new_last_maintenance_date.strftime('%Y-%m-%d')
                                else:
                                    nlast_maint_date_str = None
                                
                                if new_next_maintenance_date:
                                    nnext_maint_date_str = new_next_maintenance_date.strftime('%Y-%m-%d')
                                else:
                                    nnext_maint_date_str = None

                                if st.form_submit_button("Update Part"):
                                    if new_last_maintenance_date > datetime.now().date():
                                        st.error(
                                            "Last Maintenance Date should not be greater than the current date."
                                        )
                                    elif new_next_maintenance_date <= datetime.now().date(
                                    ):
                                        st.error(
                                            "Next Maintenance Date should be greater than the current date."
                                        )
                                    else:
                                        st.session_state.data_manager.update_spare_part(
                                            part_data['id'], {
                                                'name':
                                                part_data['name'],
                                                'description':
                                                part_data['description'],
                                                'quantity':
                                                new_quantity,
                                                'min_order_level':
                                                new_min_level,
                                                'min_order_quantity':
                                                new_min_quantity,                                   
                                                'status':
                                                new_status,
                                                'last_maintenance_date':
                                                nlast_maint_date_str,
                                                'next_maintenance_date':
                                                nnext_maint_date_str
                                            })
                                        st.success("Part updated successfully!")
                                        st.rerun()
            else:
                st.info("""
                üì± Please select Department to view stock information.
                """)

    if st.session_state.user_role in ['Admin', 'Super User']:
        with add_tab:
            cols = st.columns(2)

            with cols[0]:
                # Department selection
                parent_depts = st.session_state.data_manager.get_parent_departments()
                if parent_depts.empty:
                    st.error("No departments found. Please create departments first.")
                    return
                
                selected_parent = st.selectbox(
                    "Select Parent Department*",
                    parent_depts['id'].tolist(),
                    index=None,
                    placeholder="Select Parent Department",
                    format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0],
                    key = "AddParentDept"
                )
            
            with cols[1]:
                child_depts = st.session_state.data_manager.get_child_departments(selected_parent)
                if not child_depts.empty:            
                    selected_child = st.selectbox(
                        "Select Child Department*",
                        child_depts['id'].tolist(),
                        index=None,
                        placeholder="Select Child Department",
                        format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0],
                        key = "AddChildDept"
                    )

            with st.form("add_part_form"):
                barcode_lbl = ''
                if selected_parent and selected_child:
                    # Get department names
                    parent_dept_name = parent_depts[parent_depts['id'] == selected_parent]['name'].iloc[0]
                    child_dept_name = child_depts[child_depts['id'] == selected_child]['name'].iloc[0]
                    
                    # Get last serial number from database
                    last_serial = st.session_state.data_manager.get_last_serial_number(selected_child)
                    
                    # Generate barcode
                    barcode_lbl = generate_custom_barcode(
                        parent_dept_name, 
                        child_dept_name, 
                        last_serial
                    )
                    
                cols = st.columns(3)

                with cols[0]:
                    part_number = st.text_input("Part Number*", max_chars=20)
                    name = st.text_input("Part Name*", max_chars=100)
                    compartment_no = st.text_input("Compartment Name*", max_chars=20)
                    box_no = st.text_input("Box No*", max_chars=20)                
                    quantity = st.number_input("Initial Quantity*", min_value=0)
                    line_no = st.number_input("Line No*", min_value=1)
                    page_no = st.text_input("Page No", max_chars=20)
                    #yard_no = st.number_input("Yard No*", min_value=1)
                    
                with cols[1]:      
                    barcode = st.text_input("Barcode", value=barcode_lbl, disabled=True)              
                    order_no = st.text_input("Order No", max_chars=20)
                    material_code = st.text_input("Material Code", max_chars=50)
                    ilms_code = st.text_input("ILMS Code*", max_chars=50)
                    item_denomination = st.text_input("Item Denomination", max_chars=100)
                    min_order_level = st.number_input("Minimum Order Level", min_value=0)
                    min_order_quantity = st.number_input("Minimum Order Quantity", min_value=1) 
                    
                with cols[2]:                    
                    last_maintenance_date = st.date_input("Last Maintenance Date")     
                    next_maintenance_date = st.date_input("Next Maintenance Date")
                    status = st.selectbox("Status", ["In Store", "Operational", "Under Maintenance"])                
                    description = st.text_area("Description*")
                    remark = st.text_area("Remarks*")
                    mustered = st.checkbox("Mustered")
                    

                if st.form_submit_button("Add Part"):
                    if part_number and name and ilms_code and description and remark and compartment_no and box_no and barcode:
                        if last_maintenance_date > datetime.now().date():
                            st.error(
                                "Last Maintenance Date should not be greater than the current date."
                            )
                        elif next_maintenance_date <= datetime.now().date():
                            st.error(
                                "Next Maintenance Date should be greater than the current date."
                            )
                        else:
                            #barcode = st.session_state.barcode_handler.generate_unique_barcode()
                            success = st.session_state.data_manager.add_spare_part(
                                {
                                    'part_number': part_number,
                                    'name': name,
                                    'description': description,
                                    'quantity': quantity,
                                    'line_no': line_no,
                                    'page_no': page_no,
                                    'order_no': order_no,
                                    'material_code': material_code,
                                    'ilms_code': ilms_code,
                                    'item_denomination': item_denomination,
                                    'mustered': mustered,
                                    'department_id': selected_child,
                                    'compartment_no': compartment_no,
                                    'box_no': box_no,
                                    'remark': remark,
                                    'min_order_level': min_order_level,
                                    'min_order_quantity': min_order_quantity,
                                    'barcode': barcode,                                
                                    'status': status,
                                    'last_maintenance_date': last_maintenance_date.strftime('%Y-%m-%d'),
                                    'next_maintenance_date': next_maintenance_date.strftime('%Y-%m-%d')
                                })

                            if success:
                                st.success("Part added successfully!")
                                st.markdown(f"Generated barcode: `{barcode}`")
                                barcode_image = st.session_state.barcode_handler.generate_barcode(
                                    barcode)
                                st.image(f"data:image/png;base64,{barcode_image}")
                            else:
                                st.error("Part number already exists!")
                    else:
                        st.error("Part number, Box No, Remarks, Name, Desc, Compartment Name, ILMS Code and Barcode are required!")

        with bulk_tab:
            bulk_import_section()

def generate_custom_barcode(parent_dept_name, child_dept_name, last_serial_no):
    """
    Generate barcode in format: PAR-CH-SERIAL
    Where:
    - PAR: First 3 chars of parent department (uppercase)
    - CH: First char of child department (uppercase)
    - SERIAL: Last serial no + 1 (padded with zeros)
    """
    # Get department codes
    parent_code = parent_dept_name[:3].upper().strip()
    child_code = child_dept_name[:1].upper().strip()
    
    # Calculate next serial number
    next_serial = int(last_serial_no) + 1 if last_serial_no else 1
    
    # Format with leading zeros (e.g., 000123)
    serial_str = f"{next_serial:04d}"  # 4-digit padding
    
    # Combine components
    return f"{parent_code}-{child_code}-{serial_str}"

def download_csv_template():
    """Generate and provide a downloadable CSV template"""
    # Create sample DataFrame with required columns and example rows
    template_data = {
        'part_number': ['ABC-123', 'XYZ-456', ''],
        'name': ['Bearing 10mm', 'Hydraulic Seal', ''],
        'quantity': [5, 10, ''],
        'line_no': [1, 2, ''],
        'description': [1, 1, ''],
        'barcode': ['POP-P-001', 'POP-P-002', ''],
        'page_no': ['A12', 'B34', ''],
        'order_no': ['PO-2023-001', 'PO-2023-002', ''],
        'material_code': ['MAT-001', 'MAT-002', ''],
        'ilms_code': ['ILMS-001', 'ILMS-002', ''],
        'item_denomination': ['Pieces', 'Pieces', ''],
        'mustered': [True, False, ''],
        'compartment_name': ['C-12', 'D-34', ''],
        'box_no': ['B1', 'B2', ''],
        'remark': ['Urgent', 'Normal', '']
    }
    
    df = pd.DataFrame(template_data)
    
    # Convert to CSV
    csv = df.to_csv(index=False)
    
    # Create download button
    st.download_button(
        label="üì• Download CSV Template",
        data=csv,
        file_name="inventory_import_template.csv",
        mime="text/csv",
        help="Download template with all required columns"
    )

def bulk_import_section():
    """Bulk import from CSV with department selection"""
    #st.subheader("Bulk Import from CSV")
    # Add the download button at the top
    download_csv_template()

    # Step 1: Department Selection
    st.markdown("### Step 1: Select Department")
    
    cols = st.columns(2)

    with cols[0]:
        parent_depts = st.session_state.data_manager.get_parent_departments()
        if parent_depts.empty:
            st.error("No departments found. Please create departments first.")
            return
        
        selected_parent = st.selectbox(
            "Select Parent Department*",
            parent_depts['id'].tolist(),
            index=None,
            placeholder="Select Parent Department",
            format_func=lambda x: parent_depts[parent_depts['id'] == x]['name'].iloc[0]
        )
    
    with cols[1]:
        child_depts = st.session_state.data_manager.get_child_departments(selected_parent)
        if not child_depts.empty:
            selected_child = st.selectbox(
                "Select Child Department*",
                child_depts['id'].tolist(),
                index=None,
                placeholder="Select Child Department",
                format_func=lambda x: child_depts[child_depts['id'] == x]['name'].iloc[0]
            )
    
    # Step 2: File Upload
    if selected_parent and selected_child:
        st.markdown("### Step 2: Upload CSV File")
        uploaded_file = st.file_uploader(
            "Choose a CSV file",
            type=["csv"],
            help="Upload a CSV file with spare parts data"
        )
    
        if uploaded_file is not None and selected_child:
            try:
                # Read the uploaded file
                df = pd.read_csv(uploaded_file)
                
                # Validate required columns
                required_columns = [
                    'part_number', 'name', 'quantity', 'ilms_code', #'Remark', 'compartment_name',
                    'description', 'box_no'
                ]
                
                missing_columns = [col for col in required_columns if col not in df.columns]
                if missing_columns:
                    st.error(f"Missing required columns: {', '.join(missing_columns)}")
                    return
                
                # Data cleaning and type conversion
                df_clean = df.copy()
                
                # Handle numeric columns - fill NaN with 0 and convert to int
                numeric_cols = ['quantity', 'line_no']
                for col in numeric_cols:
                    if col in df_clean.columns:
                        df_clean[col] = df_clean[col].fillna(0).astype(int)
                
                # Handle text columns - fill NaN with empty string
                text_cols = [
                    'page_no', 'order_no', 'material_code', 'compartment_name',  'description', 'name',
                    'ilms_code', 'item_denomination', 'box_no', 'Remark'
                ]
                for col in text_cols:
                    if col in df_clean.columns:
                        df_clean[col] = df_clean[col].fillna('').astype(str)
                
                # Handle boolean column
                if 'mustered' in df_clean.columns:
                    df_clean['mustered'] = df_clean['mustered'].fillna(False).astype(bool)
                
                # Show preview with department info
                st.subheader("Import Preview")
                st.info(f"All items will be assigned to: {child_depts[child_depts['id'] == selected_child]['name'].iloc[0]}")
                
                preview_df = df_clean.head().copy()
                preview_df['assigned_department'] = child_depts[child_depts['id'] == selected_child]['name'].iloc[0]
                st.dataframe(preview_df, hide_index=True)
                
                # Map CSV columns to database columns
                column_mapping = {
                    'part_number': 'part_number',
                    'name': 'name',
                    'description': 'description',
                    'quantity': 'quantity',
                    'line_no': 'line_no',
                    'page_no': 'page_no',
                    'order_no': 'order_no',
                    'material_code': 'material_code',
                    'ilms_code': 'ilms_code',
                    'item_denomination': 'item_denomination',
                    'mustered': 'mustered',
                    'box_no': 'box_no',
                    'compartment_no' : 'compartment_name',
                    'Remark': 'remark',
                    'barcode': 'barcode'
                }
                
                df_import = df_clean.rename(columns=column_mapping)
                
                # Step 3: Import Confirmation
                st.markdown("### Step 3: Confirm Import")
                if st.button(f"Import {len(df_clean)} Records"):
                    with st.spinner(f"Importing {len(df_clean)} records..."):
                        results, success, message = st.session_state.data_manager.bulk_import_spare_parts(
                            df_import, selected_child, selected_parent
                        )
                        if success:
                            st.toast(message, icon="‚úÖ")
                            time.sleep(3)  # This will block the UI
                            # Process results
                            success_count = len([r for r in results if r['status'] == 'success'])
                            failed_count = len([r for r in results if r['status'] == 'failed'])
                            
                            # Create results dataframe
                            results_df = pd.DataFrame(results)
                            
                            # Show summary
                            st.success(f"Successfully imported {success_count} records")
                            if failed_count > 0:
                                st.error(f"Failed to import {failed_count} records")
                            
                            # Display results table with tabs
                            tab1, tab2 = st.tabs(["All Results", "Failed Only"])
                            
                            with tab1:
                                st.dataframe(results_df, hide_index=True)
                            
                            with tab2:
                                failed_df = results_df[results_df['status'] == 'failed']
                                st.dataframe(failed_df, hide_index=True)
                            
                            # Download buttons
                            st.markdown("### Download Import Results")
                            col1, col2 = st.columns(2)
                            
                            with col1:
                                st.download_button(
                                    label="Download Full Results (CSV)",
                                    data=convert_df_to_csv(results_df),
                                    file_name="import_results_all.csv",
                                    mime="text/csv"
                                )
                            
                            with col2:
                                st.download_button(
                                    label="Download Failed Only (CSV)",
                                    data=convert_df_to_csv(failed_df),
                                    file_name="import_results_failed.csv",
                                    mime="text/csv"
                                )
                            #st.rerun()
                        else:
                            st.error(message)
                            
            except Exception as e:
                st.error(f"Error processing file: {str(e)}")

def convert_df_to_csv(df):
    """Convert dataframe to CSV for download"""
    return df.to_csv(index=False).encode('utf-8')

if __name__ == "__main__":
    render_inventory_page()
</file>

<file path="pages/operations.py">
import streamlit as st
from data_manager import DataManager
from barcode_handler import BarcodeHandler
from user_management import login_required, init_session_state
from datetime import datetime
import navbar
from app_settings import set_page_configuration
import time

set_page_configuration()

current_page = "Operations"
st.header(current_page)

# Initialize session state
init_session_state()

navbar.nav(current_page)


@login_required
def render_operations_page():
    # Initialize session state if needed
    if 'data_manager' not in st.session_state:
        st.session_state.data_manager = DataManager()
    if 'barcode_handler' not in st.session_state:
        st.session_state.barcode_handler = BarcodeHandler()
    if 'last_scans' not in st.session_state:
        st.session_state.last_scans = []

    #st.title("Operations")

    # Show any active alerts
    lpl_stock = st.session_state.data_manager.get_last_piece_stock_items()
    if not lpl_stock.empty:
        with st.expander("üö® Last Piece Stock Alerts", expanded=False):
            st.warning(f"{len(lpl_stock)} items need attention!")
            for _, item in lpl_stock.iterrows():
                st.error(f"""
                    **{item['name']}** (Part #{item['part_number']})
                    - Current Stock: {item['quantity']}
                    - Minimum Level: {item['min_order_level']}
                    - Suggested Order: {item['min_order_quantity']}
                """)

    low_stock = st.session_state.data_manager.get_low_stock_items()
    if not low_stock.empty:
        with st.expander("üö® Low Stock Alerts", expanded=False):
            st.warning(f"{len(low_stock)} items need attention!")
            for _, item in low_stock.iterrows():
                st.error(f"""
                    **{item['name']}** (Part #{item['part_number']})
                    - Current Stock: {item['quantity']}
                    - Minimum Level: {item['min_order_level']}
                    - Suggested Order: {item['min_order_quantity']}
                """)

    tab1, tab2 = st.tabs(
        ["Barcode Scanner Interface", "Check-In / Check-Out"])

    with tab1:
        #st.subheader("Barcode Scanner Interface")
        st.info("""
        üì± Use this interface with a physical barcode scanner or enter the barcode manually.
        The scanner should work automatically when you scan a barcode.
        """)

        col1, col2 = st.columns([2, 1])
        with col1:
            barcode_input = st.text_input("Scan or Enter Barcode",
                                          key="barcode_scanner",
                                          placeholder="ABC-D-1234")

            if barcode_input:
                is_valid, cleaned_barcode = st.session_state.barcode_handler.validate_barcode(
                    barcode_input)
                #print("barcode_input:", barcode_input)  # Add this temporarily
                #print("is_valid:", is_valid)  # Add this temporarily
                if is_valid:
                    success, part = st.session_state.barcode_handler.get_part_by_barcode(
                        st.session_state.data_manager, barcode_input)
                    if success:
                        #st.success("Part found!")

                        # Show alert if item is low on stock
                        if part['quantity'] <= part['min_order_level']:
                            st.warning(
                                f"‚ö†Ô∏è Low stock alert: Only {part['quantity']} units remaining!"
                            )

                        st.json({
                            "Name": part['name'],
                            "Part Number": part['part_number'],
                            "Box No": part['box_no'],
                            "Compartment Name": part['compartment_no'],
                            "ILMS Code": part['ilms_code'],
                            "Current Quantity": int(part['quantity']),
                            "Min Order Level": int(part['min_order_level'])
                        })

                        cols = st.columns(2)
                        with cols[0]:
                            # Quick actions for scanned part
                            action = st.selectbox("Select Action",
                                                ["Check In", "Check Out"],
                                                key="barcode_action")

                            quantity = st.number_input(
                                "Quantity",
                                min_value=1,
                                max_value=int(part['quantity'])
                                if action == "Check Out" else None,
                                value=1,
                                key="barcode_quantity")
                        with cols[1]:
                            if action == "Check Out":
                                reason = st.selectbox("Reason", ["Operational", "Maintenance", "Damaged"])
                                remarks = st.text_area("Remarks")
                            else:
                                reason = st.selectbox("Reason", ["New", "After Maintenance"])
                                remarks = st.text_area("Remarks")

                        if st.button(f"Confirm {action}"):
                            transaction_type = 'check_in' if action == "Check In" else 'check_out'

                            success, error_msg = st.session_state.data_manager.record_transaction(
                                part['id'], transaction_type, quantity, reason, remarks)

                            if success:
                                st.success(
                                    f"Successfully {action.lower()}ed {quantity} units"
                                )

                                # Check if action triggered low stock alert
                                updated_df = st.session_state.data_manager.get_part_by_id(
                                    part['id'])
                                if updated_df is not None and not updated_df.empty:
                                    updated_part = updated_df.iloc[0]
                                    if updated_part[
                                            'quantity'] <= updated_part[
                                                'min_order_level']:
                                        st.warning(
                                            f"‚ö†Ô∏è Stock Alert: {updated_part['name']} is now below minimum stock level!"
                                        )

                                st.session_state.last_scans.append(
                                    f"{datetime.now().strftime('%H:%M:%S')} - {part['name']}"
                                )
                                st.rerun()
                            else:
                                st.error(f"Transaction failed: {error_msg}")
                    else:
                        st.error("Barcode not found in system")
                else:
                    st.error(
                        "Invalid barcode format. Expected format: 3 chars - 1 char - 4 digits (ABC-D-1234)"
                    )

        with col2:
            if len(barcode_input) > 0:
                barcode_image = st.session_state.barcode_handler.generate_barcode(barcode_input)
                st.image(f"data:image/png;base64,{barcode_image}")
            st.markdown("### Last Scanned")
            for scan in st.session_state.last_scans[-5:]:
                st.text(scan)

    with tab2:
        df = st.session_state.data_manager.get_all_parts()

        if not df.empty:
            selected_part = st.selectbox("Select Part",
                                         df['description'].tolist(),
                                         key="checkin_part")

            part_data = df[df['description'] == selected_part].iloc[0]

            # Show stock level warning if applicable
            if part_data['quantity'] <= part_data['min_order_level']:
                st.warning(
                    f"‚ö†Ô∏è Low stock alert: Only {part_data['quantity']} units remaining!"
                )
            else:
                st.info(f"Current quantity: {part_data['quantity']}")

            col1, col2 = st.columns(2)

            with col1:
                with st.form("check_in_form"):
                    check_in_quantity = st.number_input("Check-In Quantity",
                                                        min_value=1,
                                                        value=1,
                                                        key="checkin_quantity")
                    reason = st.selectbox("Reason", ["New", "After Maintenance"])
                    remarks = st.text_area("Remarks")
                    
                    if st.form_submit_button("Check-In"):
                        success, error_msg = st.session_state.data_manager.record_transaction(
                            part_data['id'], 'check_in', check_in_quantity, reason, remarks)
                        if success:
                            st.success(f"Checked in {check_in_quantity} units")
                            time.sleep(3)  # This will block the UI
                            st.rerun()
                        else:
                            st.error(f"Transaction failed: {error_msg}")

            with col2:
                with st.form(f"check_out_form_{part_data['id']}"):  # Unique form key per part
                    # Get the available quantity
                    available_quantity = int(part_data['quantity'])
                    
                    if available_quantity > 0:
                        check_out_quantity = st.number_input(
                            "Check-Out Quantity",
                            min_value=1,
                            max_value=available_quantity,
                            value=min(1, available_quantity),
                            key=f"checkout_quantity_{part_data['id']}"
                        )
                        reason = st.selectbox("Reason", ["Operational", "Maintenance", "Damaged"])
                        remarks = st.text_area("Remarks")
                    else:
                        st.warning("This item is currently out of stock")
                        check_out_quantity = 0  # Default value when out of stock
                    
                    # Submit button should be at form level, not nested in if
                    submitted = st.form_submit_button("Check-Out", disabled=(available_quantity <= 0))
                    
                    if submitted and available_quantity > 0:
                        success, error_msg = st.session_state.data_manager.record_transaction(
                            part_data['id'], 'check_out', check_out_quantity, reason, remarks)

                        if success:
                            # Check for low stock alert
                            updated_df = st.session_state.data_manager.get_part_by_id(part_data['id'])
                            if updated_df is not None and not updated_df.empty:
                                updated_part = updated_df.iloc[0]
                                if updated_part['quantity'] <= updated_part['min_order_level']:
                                    st.warning(
                                        f"‚ö†Ô∏è Stock Alert: {updated_part['name']} is now below minimum stock level!"
                                    )
                            
                            st.success(f"Successfully checked out {check_out_quantity} units of {part_data['name']}")
                            #st.toast(message, icon="‚úÖ")
                            time.sleep(3)  # This will block the UI
                            st.rerun()
                        else:
                            st.error(f"Transaction failed: {error_msg}")


if __name__ == "__main__":
    render_operations_page()
</file>

</files>
